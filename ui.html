<!-- Google Fonts with fallback -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"
  onerror="this.remove()">

<style>
  /* CSS Custom Properties (Design Tokens) */
  :root {
    /* Colors - Green & Purple Theme */
    --color-primary: #8b5cf6;
    --color-primary-hover: #7c3aed;
    --color-primary-light: #f3f4f6;
    --color-success: #10b981;
    --color-success-hover: #059669;
    --color-checkbox: #10b981;
    --color-checkbox-light: #ecfdf5;
    --color-success-light: #ecfdf5;
    --color-warning: #f59e0b;
    --color-warning-light: #fef3c7;
    --color-danger: #ef4444;
    --color-danger-hover: #dc2626;
    --color-danger-light: #fef2f2;
    --color-gray-50: #f9fafb;
    --color-gray-100: #f3f4f6;
    --color-gray-200: #e5e7eb;
    --color-gray-300: #d1d5db;
    --color-gray-400: #9ca3af;
    --color-gray-500: #6b7280;
    --color-gray-600: #4b5563;
    --color-gray-700: #374151;
    --color-gray-800: #1f2937;
    --color-gray-900: #111827;

    /* Typography */
    --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    --font-size-xs: 11px;
    --font-size-sm: 12px;
    --font-size-base: 14px;
    --font-size-lg: 16px;
    --font-size-xl: 18px;
    --font-size-2xl: 20px;
    --font-size-3xl: 24px;

    /* Spacing */
    --spacing-1: 4px;
    --spacing-2: 8px;
    --spacing-3: 12px;
    --spacing-4: 16px;
    --spacing-5: 20px;
    --spacing-6: 24px;
    --spacing-8: 32px;
    --spacing-10: 40px;

    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 6px;
    --radius-lg: 8px;
    --radius-xl: 12px;

    /* Shadows */
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  }

  /* Reset and Base Styles */
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: var(--font-family);
    font-size: var(--font-size-sm);
    line-height: 1.5;
    color: var(--color-gray-700);
    background: #ffffff;
    padding: var(--spacing-4) 16px;
    overflow: hidden;
    position: relative;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Dark theme for specific screens */
  body:has(#link-screen.active),
  body:has(#export-screen.active),
  body:has(#export-confirmation-screen.active),
  body:has(#export-instructions-screen.active) {
    background: #1a1a24;
    padding: 0;
  }

  /* Remove body padding effect for validation results screen */
  #validation-results-screen {
    margin-top: calc(-1 * var(--spacing-4));
  }

  /* Screen Management */
  .screen {
    display: none !important;
  }

  .screen.active {
    display: block !important;
  }

  /* Typography */
  .header {
    margin-bottom: var(--spacing-6);
  }

  .title {
    font-size: var(--font-size-2xl);
    font-weight: 700;
    color: var(--color-gray-900);
    margin: 0 0 var(--spacing-1) 0;
    letter-spacing: -0.025em;
  }

  .subtitle {
    font-size: var(--font-size-base);
    color: var(--color-gray-500);
    line-height: 1.2;
    margin: 0;
  }

  .section {
    margin-bottom: var(--spacing-6);
  }

  .section-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    color: var(--color-gray-900);
    margin-bottom: var(--spacing-2);
    letter-spacing: -0.025em;
  }

  /* Form Controls */
  .dropdown {
    width: 100%;
    padding: var(--spacing-3) var(--spacing-8) var(--spacing-3) var(--spacing-3);
    border: 1px solid var(--color-gray-300);
    border-radius: var(--radius-lg);
    background: #ffffff;
    color: var(--color-gray-700);
    font-size: var(--font-size-base);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: var(--spacing-3);
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='m6 9 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right var(--spacing-3) center;
    background-size: 16px;
    box-shadow: var(--shadow-sm);
  }

  .dropdown:hover {
    border-color: var(--color-gray-400);
    box-shadow: var(--shadow-md);
  }

  .dropdown:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px var(--color-primary-light);
  }

  .dropdown.attached {
    background: #8B5CF6;
    color: white;
    border-color: #8B5CF6;
    font-weight: 600;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='m6 9 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right var(--spacing-3) center;
    background-size: 16px;
  }

  .dropdown.attached:hover {
    background: #7C3AED;
    border-color: #7C3AED;
  }

  .dropdown.attached:focus {
    outline: none;
    border-color: #8B5CF6;
    box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    background: #8B5CF6;
  }

  /* Custom Dropdown Component */
  .custom-dropdown {
    position: relative;
    width: 100%;
    margin-bottom: var(--spacing-3);
  }

  .dropdown-selected {
    width: 100%;
    padding: var(--spacing-3) var(--spacing-8) var(--spacing-3) var(--spacing-3);
    border: 1px solid var(--color-gray-300);
    border-radius: var(--radius-lg);
    background: #ffffff;
    color: var(--color-gray-700);
    font-size: var(--font-size-base);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: var(--shadow-sm);
  }

  .dropdown-selected:hover {
    border-color: var(--color-gray-400);
    box-shadow: var(--shadow-md);
  }

  .dropdown-arrow {
    width: 16px;
    height: 16px;
    transition: transform 0.2s ease;
    flex-shrink: 0;
  }

  .custom-dropdown.open .dropdown-arrow {
    transform: rotate(180deg);
  }

  .dropdown-options {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid var(--color-gray-300);
    border-top: none;
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
    box-shadow: var(--shadow-lg);
    z-index: 1000;
    max-height: 200px;
    overflow-y: auto;
    display: none;
  }

  .custom-dropdown.open .dropdown-options {
    display: block;
  }

  .dropdown-option {
    padding: var(--spacing-3);
    cursor: pointer;
    transition: background-color 0.2s ease;
    font-size: var(--font-size-base);
    color: var(--color-gray-700);
  }

  .dropdown-option:hover {
    background: var(--color-gray-50);
  }

  .dropdown-option.selected {
    background: var(--color-success-light);
    color: var(--color-success);
    font-weight: 600;
  }

  /* Attached state styling */
  .custom-dropdown.attached .dropdown-selected {
    background: #8B5CF6;
    color: white;
    border-color: #8B5CF6;
    font-weight: 600;
  }

  .custom-dropdown.attached .dropdown-selected:hover {
    background: #7C3AED;
    border-color: #7C3AED;
  }

  .custom-dropdown.attached .dropdown-arrow {
    color: white;
  }

  /* Button System */
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-2);
    padding: var(--spacing-3) var(--spacing-4);
    font-family: var(--font-family);
    font-size: var(--font-size-base);
    font-weight: 600;
    line-height: 1;
    border: 1px solid transparent;
    border-radius: var(--radius-lg);
    cursor: pointer;
    transition: all 0.2s ease;
    text-decoration: none;
    white-space: nowrap;
    user-select: none;
    box-shadow: var(--shadow-sm);
  }

  .btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px var(--color-primary-light);
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Primary Button */
  .btn-primary {
    background: #2da44e;
    color: white;
    border: 1px solid rgba(27, 31, 36, 0.15);
    border-radius: 6px;
    padding: 6px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
    box-shadow: 0 1px 0 rgba(27, 31, 36, 0.1);
  }

  .btn-primary:hover {
    background: #2c974b;
    border-color: rgba(27, 31, 36, 0.15);
    box-shadow: 0 1px 0 rgba(27, 31, 36, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.03);
  }

  .btn-primary:active {
    background: #298e46;
    box-shadow: inset 0 1px 0 rgba(0, 0, 0, 0.1);
  }

  .btn-primary:disabled {
    background: #999;
    color: white;
    border-color: #999;
    cursor: not-allowed;
    box-shadow: none;
  }

  .btn-primary:disabled:hover {
    background: #999;
    border-color: #999;
    box-shadow: none;
  }

  /* Legacy primary button for compatibility */
  .primary-button {
    background: var(--color-primary);
    color: white;
    border-color: var(--color-primary);
  }

  .primary-button:hover {
    background: var(--color-primary-hover);
    border-color: var(--color-primary-hover);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  /* Run Validation Button - Black when active */
  #run-validation:not(:disabled) {
    background: var(--color-gray-900) !important;
    border-color: var(--color-gray-900) !important;
    color: white !important;
  }

  #run-validation:not(:disabled):hover {
    background: var(--color-gray-800) !important;
    border-color: var(--color-gray-800) !important;
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  /* Secondary Button */
  .secondary-button,
  .btn-secondary {
    background: var(--color-gray-100);
    color: var(--color-gray-700);
    border-color: var(--color-gray-300);
  }

  .secondary-button:hover,
  .btn-secondary:hover {
    background: var(--color-gray-200);
    border-color: var(--color-gray-400);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  /* Success Button */
  .btn-success {
    background: var(--color-success);
    color: white;
    border-color: var(--color-success);
  }

  .btn-success:hover {
    background: var(--color-success-hover);
    border-color: var(--color-success-hover);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  /* Danger Button */
  .btn-danger {
    background: white;
    color: #cf222e;
    border: 1px solid #d0d7de;
    padding: 6px 16px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .btn-danger:hover {
    background: #f6f8fa;
    border-color: #cf222e;
  }

  .btn-danger:active {
    background: #eaeef2;
  }

  /* Icon Button */
  .btn-icon {
    background: white;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 6px;
    min-width: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn-icon:hover {
    background: #f6f8fa;
    border-color: #afb8c1;
  }

  .btn-icon .icon {
    width: 16px;
    height: 16px;
    display: inline-block;
    vertical-align: middle;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }



  /* Button Sizes */
  .btn-sm {
    padding: var(--spacing-2) var(--spacing-3);
    font-size: var(--font-size-sm);
  }

  .btn-lg {
    padding: var(--spacing-4) var(--spacing-6);
    font-size: var(--font-size-lg);
  }

  /* Full Width Button */
  .btn-full {
    width: 100%;
  }

  /* Legacy button classes for compatibility */
  .primary-button {
    width: 100%;
    padding: var(--spacing-3) var(--spacing-4);
    background: #10b981;
    color: white;
    border: none;
    border-radius: var(--radius-lg);
    font-size: var(--font-size-base);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: none;
  }

  .primary-button:hover {
    background: var(--color-success-hover);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  .primary-button:disabled {
    background: #999;
    cursor: not-allowed;
    opacity: 1;
  }

  .primary-button:disabled:hover {
    background: #999;
    box-shadow: none;
    transform: none;
  }

  .secondary-button {
    background: var(--color-gray-100);
    color: var(--color-gray-700);
    border: 1px solid var(--color-gray-300);
    border-radius: var(--radius-lg);
    padding: var(--spacing-3) var(--spacing-4);
    cursor: pointer;
    font-size: var(--font-size-base);
    font-weight: 600;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
  }

  .secondary-button:hover {
    background: var(--color-gray-200);
    border-color: var(--color-gray-400);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  /* Tab System */
  .category-tab-button {
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 500;
    border-radius: 4px;
    border: none;
    background: transparent;
    color: #6b7280;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
    margin: 0;
  }

  .category-tab-button:hover {
    color: #374151;
    background: rgba(0, 0, 0, 0.05);
  }

  .category-tab-button.active {
    background: #3b82f6;
    color: white;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
  }

  .status-tab-button {
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 500;
    border-radius: 4px;
    border: none;
    background: transparent;
    color: #6b7280;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
    margin: 0;
  }

  .status-tab-button:hover {
    color: #374151;
    background: rgba(0, 0, 0, 0.05);
  }

  .status-tab-button.active {
    background: #3b82f6;
    color: white;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
  }

  /* Tab container styling */
  #category-tabs,
  #status-tabs {
    border: 1px solid #e5e7eb !important;
    background: #f9fafb !important;
    border-radius: 6px !important;
    padding: 2px !important;
  }

  /* Dropdown styling */
  .dropdown-trigger:hover {
    background: #f9fafb !important;
    border-color: #9ca3af !important;
  }

  /* Update button styling */
  .update-btn:not(:disabled) {
    background: #3b82f6 !important;
    color: white !important;
    cursor: pointer !important;
  }

  .update-btn:not(:disabled):hover {
    background: #2563eb !important;
    color: white !important;
  }

  /* Action button hover effects */
  #minimize-btn:hover,
  #hamburger-menu-btn:hover {
    background: #f3f4f6 !important;
  }

  /* Corner radius token states - matching the 3 exact designs */

  /* State 1: Value has Token - Small gray badge inside white container */
  .corner-token-badge.existing-token {
    background: #f3f4f6 !important;
    color: #111827 !important;
    border: none !important;
    font-weight: 500 !important;
    font-size: 11px !important;
    padding: 1px 4px !important;
    border-radius: 2px !important;
    display: inline-block !important;
    line-height: 1.2 !important;
  }

  .corner-token-badge.existing-token:hover {
    background: #e5e7eb !important;
  }

  /* State 2: Value Doesn't have token - White button with gray border */
  .corner-radius-input {
    background: white !important;
    color: #9ca3af !important;
    font-weight: 500 !important;
    font-size: 11px !important;
    border-radius: 3px !important;
    /* Border will be set inline for dynamic styling */
  }



  /* Specific classes for different corner states */
  .corner-radius-input.hardcoded-zero {
    border: 1px solid #d1d5db !important;
  }

  .corner-radius-input.hardcoded-nonzero {
    border: 1px solid #fca5a5 !important;
  }

  .corner-radius-input.hardcoded-zero:hover {
    border-color: #9ca3af !important;
  }

  .corner-radius-input.hardcoded-nonzero:hover {
    border-color: #f87171 !important;
  }

  /* State 3: User selected Token - Blue background with blue border */
  .corner-token-badge.user-selection {
    background: #eff6ff !important;
    color: #111827 !important;
    border: 2px solid #3b82f6 !important;
    font-weight: 500 !important;
    font-size: 11px !important;
    padding: 2px 4px !important;
    border-radius: 3px !important;
    width: 40px !important;
    height: 24px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  .corner-token-badge.user-selection:hover {
    background: #dbeafe !important;
    border-color: #2563eb !important;
  }

  /* Legacy input field token selected state */
  .corner-radius-input[data-has-token="true"] {
    background: #ecfdf5 !important;
    border-color: #10b981 !important;
    color: #065f46 !important;
    font-weight: 600 !important;
    box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.1) !important;
  }

  .corner-radius-input[data-has-token="true"]:hover {
    background: #d1fae5 !important;
    border-color: #059669 !important;
  }

  /* Validation Components */
  .validation-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-4);
    border: 1px solid var(--color-gray-200);
    border-radius: var(--radius-lg);
    margin-bottom: var(--spacing-3);
    background: white;
    box-shadow: var(--shadow-sm);
    transition: all 0.2s ease;
  }

  .validation-item:hover {
    box-shadow: var(--shadow-md);
    border-color: var(--color-gray-300);
  }

  .validation-item-left {
    display: flex;
    align-items: center;
    gap: var(--spacing-3);
    flex: 1;
  }

  .validation-badge {
    padding: var(--spacing-1) var(--spacing-2);
    border-radius: var(--radius-sm);
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .validation-badge.spacing {
    background: var(--color-warning-light);
    color: var(--color-warning);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .validation-badge.text {
    background: var(--color-primary-light);
    color: var(--color-primary);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .validation-actions {
    display: flex;
    gap: var(--spacing-2);
  }

  /* Card Components */
  .card {
    background: white;
    border: 1px solid var(--color-gray-200);
    border-radius: var(--radius-xl);
    padding: var(--spacing-4);
    box-shadow: var(--shadow-sm);
    transition: all 0.2s ease;
  }

  .card:hover {
    box-shadow: var(--shadow-lg);
    border-color: var(--color-gray-300);
    transform: translateY(-2px);
  }

  .card-header {
    margin-bottom: var(--spacing-4);
    padding-bottom: var(--spacing-3);
    border-bottom: 1px solid var(--color-gray-100);
  }

  .card-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    color: var(--color-gray-900);
    margin: 0;
  }

  .card-subtitle {
    font-size: var(--font-size-sm);
    color: var(--color-gray-500);
    margin: var(--spacing-1) 0 0 0;
  }

  /* Form Components */
  .form-group {
    margin-bottom: var(--spacing-4);
  }

  .form-label {
    display: block;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-gray-700);
    margin-bottom: var(--spacing-2);
  }

  .form-input {
    width: 100%;
    padding: var(--spacing-3);
    border: 1px solid var(--color-gray-300);
    border-radius: var(--radius-lg);
    font-size: var(--font-size-base);
    color: var(--color-gray-700);
    background: white;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
  }

  .form-input:hover {
    border-color: var(--color-gray-400);
  }

  .form-input:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px var(--color-primary-light);
  }

  /* Checkbox Styles */
  .checkbox-group {
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-3);
    padding: var(--spacing-4);
    border: 2px solid var(--color-gray-200);
    border-radius: var(--radius-xl);
    background: white;
    transition: all 0.2s ease;
    cursor: pointer;
    margin-bottom: var(--spacing-4);
  }

  .checkbox-group:hover {
    border-color: var(--color-gray-300);
    box-shadow: var(--shadow-sm);
  }

  .checkbox-group.selected {
    border-color: var(--color-checkbox);
    background: var(--color-checkbox-light);
  }

  .checkbox-group input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: 24px;
    height: 24px;
    margin-top: 0px;
    border: 2px solid var(--color-gray-200);
    border-radius: 6px;
    background: white;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .checkbox-group input[type="checkbox"]:checked {
    background: var(--color-checkbox);
    border-color: var(--color-checkbox);
  }

  .checkbox-group input[type="checkbox"]:checked::after {
    content: '';
    position: absolute;
    left: 3px;
    top: 3px;
    width: 16px;
    height: 16px;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M20 6 9 17l-5-5'/%3e%3c/svg%3e");
    background-size: 16px 16px;
    background-repeat: no-repeat;
    background-position: center;
  }

  .checkbox-content {
    flex: 1;
  }

  .checkbox-title {
    font-weight: 600;
    color: var(--color-gray-900);
    margin-bottom: var(--spacing-1);
    font-size: 15px;
  }

  .checkbox-description {
    font-size: 13px;
    color: var(--color-gray-500);
    margin-bottom: var(--spacing-2);
    line-height: 1.4;
  }

  .checkbox-meta {
    font-size: 13px;
    font-weight: 500;
  }

  .checkbox-meta .count {
    color: var(--color-checkbox);
  }

  .checkbox-meta .link {
    color: var(--color-primary);
    text-decoration: none;
    margin-left: var(--spacing-2);
  }

  .checkbox-meta .link:hover {
    text-decoration: underline;
  }

  /* Status Messages */
  .status-message {
    padding: var(--spacing-4);
    border-radius: var(--radius-lg);
    border: 1px solid;
    margin-bottom: var(--spacing-4);
    font-size: var(--font-size-base);
  }

  .status-message.success {
    background: var(--color-success-light);
    border-color: var(--color-success);
    color: var(--color-success);
  }

  .status-message.warning {
    background: var(--color-warning-light);
    border-color: var(--color-warning);
    color: var(--color-warning);
  }

  .status-message.info {
    background: var(--color-primary-light);
    border-color: var(--color-primary);
    color: var(--color-primary);
  }

  /* Gradient Text */
  .gradient-text {
    background: linear-gradient(90deg, hsl(290 80% 60%) 0%, hsl(262 83% 58%) 50%, hsl(190 80% 60%) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Utility Classes */
  .text-center {
    text-align: center;
  }

  .text-sm {
    font-size: var(--font-size-sm);
  }

  .text-lg {
    font-size: var(--font-size-lg);
  }

  .font-medium {
    font-weight: 500;
  }

  .font-semibold {
    font-weight: 600;
  }

  .font-bold {
    font-weight: 700;
  }

  .text-gray-500 {
    color: var(--color-gray-500);
  }

  .text-gray-700 {
    color: var(--color-gray-700);
  }

  .text-gray-900 {
    color: var(--color-gray-900);
  }

  .mb-2 {
    margin-bottom: var(--spacing-2);
  }

  .mb-4 {
    margin-bottom: var(--spacing-4);
  }

  .mt-2 {
    margin-top: var(--spacing-2);
  }

  .mt-4 {
    margin-top: var(--spacing-4);
  }

  /* SVG Icon System */
  .icon {
    width: 16px;
    height: 16px;
    display: inline-block;
    vertical-align: middle;
    fill: currentColor;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .icon-sm {
    width: 14px;
    height: 14px;
  }

  .icon-lg {
    width: 20px;
    height: 20px;
  }

  .icon-xl {
    width: 24px;
    height: 24px;
  }

  /* Loading Component */
  .kova-loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #0a0a0a;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    font-family: var(--font-family);
  }

  .kova-loader.active {
    display: flex;
  }

  .kova-loader-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    animation: kovaFadeIn 0.3s ease-out;
  }

  .kova-logo-wrapper {
    margin-bottom: -4.5rem;
    animation: kovaPulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .kova-logo-svg {
    width: 288px;
    height: 288px;
    color: #8b5cf6;
  }

  .kova-logo-text {
    font-size: 3.75rem;
    font-weight: 700;
    background: linear-gradient(to right, #d946ef, #8b5cf6, #3b82f6);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.025em;
    margin: 0;
  }

  .kova-loading-dots {
    display: flex;
    gap: 0.75rem;
    margin-top: 1rem;
  }

  .kova-dot {
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 50%;
    background: #8b5cf6;
    animation: kovaBounce 1s infinite;
  }

  .kova-dot:nth-child(2) {
    animation-delay: 150ms;
  }

  .kova-dot:nth-child(3) {
    animation-delay: 300ms;
  }

  .kova-loading-text {
    font-size: 0.875rem;
    color: #71717a;
    margin-top: 1rem;
    animation: kovaPulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  @keyframes kovaFadeIn {
    0% {
      opacity: 0;
      transform: translateY(10px);
    }

    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes kovaPulse {

    0%,
    100% {
      opacity: 1;
    }

    50% {
      opacity: 0.5;
    }
  }

  @keyframes kovaBounce {

    0%,
    100% {
      transform: translateY(0);
    }

    50% {
      transform: translateY(-0.5rem);
    }
  }

  /* Light Theme Loader */
  .kova-loader.light {
    background: #ffffff;
  }

  /* Play Icon for Buttons */
  .play-icon {
    width: 16px;
    height: 16px;
    fill: currentColor;
    stroke: none;
  }

  .primary-button {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .primary-button:hover {
    background: var(--color-success-hover);
  }

  .large-add-button {
    width: 100%;
    padding: 20px 16px;
    background: var(--color-success);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-top: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: var(--shadow-sm);
  }

  .large-add-button:hover {
    background: var(--color-success-hover);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  .button-row {
    display: flex;
    gap: 8px;
    margin-top: 12px;
  }

  .button-row button {
    flex: 1;
    margin-top: 0;
  }

  .blue-button {
    padding: 10px 16px;
    background: var(--color-primary);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .blue-button:hover {
    background: var(--color-primary-hover);
  }

  .red-button {
    padding: 10px 16px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .red-button:hover {
    background: #c82333;
  }

  .gray-button {
    padding: 10px 16px;
    background: #c7c7c7;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .gray-button:hover {
    background: #5a6268;
  }

  .status-message {
    padding: 12px;
    border-radius: 6px;
    font-size: 11px;
    line-height: 1.4;
    margin-bottom: 16px;
    background: #f5f5f5;
    color: #666;
    border: 1px solid #e0e0e0;
  }

  .play-icon::before {
    content: "▶";
    font-size: 10px;
  }

  /* Text Style Components */
  .text-style-group {
    margin-bottom: var(--spacing-6);
  }

  .text-style-group-title {
    font-size: var(--font-size-lg);
    font-weight: 700;
    color: var(--color-gray-900);
    margin-bottom: var(--spacing-4);
    padding-bottom: var(--spacing-2);
    border-bottom: 2px solid var(--color-gray-100);
    letter-spacing: -0.025em;
  }

  .text-style-item {
    border: 1px solid var(--color-gray-200);
    border-radius: var(--radius-lg);
    padding: var(--spacing-4);
    margin-bottom: var(--spacing-3);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: white;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
  }

  .text-style-item:hover {
    border-color: var(--color-gray-300);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
  }

  .text-style-item.selected {
    border-color: var(--color-primary);
    background: var(--color-primary-light);
    box-shadow: var(--shadow-md);
  }

  .text-style-info h4 {
    font-size: var(--font-size-base);
    font-weight: 600;
    color: var(--color-primary);
    margin: 0 0 var(--spacing-1) 0;
  }

  .text-style-info p {
    font-size: var(--font-size-sm);
    color: var(--color-gray-500);
    margin: 0;
    line-height: 1.4;
  }

  .text-style-size {
    font-size: var(--font-size-base);
    font-weight: 600;
    color: var(--color-primary);
    background: var(--color-primary-light);
    padding: var(--spacing-1) var(--spacing-2);
    border-radius: var(--radius-sm);
  }

  /* Slide-in Screen Styles */
  .slide-screen {
    position: absolute;
    top: 0;
    left: 100%;
    width: 100%;
    height: 100%;
    background: white;
    transition: left 0.3s ease;
    z-index: 10;
    overflow: hidden;
    padding: var(--spacing-4);
    box-sizing: border-box;
  }

  .slide-screen.active {
    left: 0;
  }

  /* Visual feedback styles removed - no background changes during updates */

  .update-btn-success {
    background: #6b7280 !important;
    color: white !important;
    border-color: #6b7280 !important;
    position: relative;
    overflow: hidden;
  }

  .update-btn-success::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
    font-weight: bold;
    opacity: 0;
    animation: checkmark-appear 0.3s ease-in-out 0.2s forwards;
  }

  .update-btn-success .btn-text {
    opacity: 0;
    animation: text-fade-out 0.3s ease-in-out forwards;
  }

  .success-flash {
    animation: success-flash 0.6s ease-in-out;
  }

  @keyframes shimmer {
    0% {
      left: -100%;
    }

    100% {
      left: 100%;
    }
  }

  @keyframes checkmark-appear {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.5);
    }

    100% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }

  @keyframes text-fade-out {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 0;
    }
  }

  @keyframes success-flash {
    0% {
      background-color: transparent;
    }

    50% {
      background-color: rgba(40, 167, 69, 0.1);
    }

    100% {
      background-color: transparent;
    }
  }

  /* Success animations removed - no visual feedback during updates */

  /* Sticky Footer */
  .sticky-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    border-top: 1px solid var(--color-gray-200);
    padding: var(--spacing-4) 16px;
    box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
    z-index: 1000;
  }

  .footer-tip {
    margin-bottom: var(--spacing-3);
    padding: var(--spacing-3);
    background: #f8f9fa;
    border-radius: var(--radius-md);
    font-size: 13px;
    color: #666;
    line-height: 1.4;
    text-align: center;
  }

  /* Fixed height layout */
  body {
    height: 900px;
    overflow: hidden;
  }

  #home-screen {
    height: 100vh;
    display: flex;
    flex-direction: column;
    padding-bottom: 140px;
    /* Space for sticky footer */
  }

  /* Make sections that aren't validation options flex-shrink */
  #home-screen .section:not(.validation-section) {
    flex-shrink: 0;
  }

  /* Make the validation section take remaining space */
  .validation-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    /* Important for flex child to shrink */
  }

  .validation-header {
    flex-shrink: 0;
    /* Don't shrink the header */
  }

  .validation-options-scroll {
    flex: 1;
    overflow-y: auto;
    padding-right: 8px;
    /* Space for scrollbar */
    margin-right: -8px;
    /* Offset the padding */
    min-height: 0;
    /* Important for scrolling to work */
    max-height: 400px;
    /* Force a maximum height to ensure scrolling */
  }

  /* Custom scrollbar styling */
  .validation-options-scroll::-webkit-scrollbar {
    width: 6px;
  }

  .validation-options-scroll::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }

  .validation-options-scroll::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
  }

  .validation-options-scroll::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }

  /* Custom scrollbar styling for validation results */
  #validation-results-content::-webkit-scrollbar {
    width: 6px;
  }

  #validation-results-content::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }

  #validation-results-content::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
  }

  #validation-results-content::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }

  /* Custom scrollbar styling for collapsed view */
  #collapsed-view-content::-webkit-scrollbar {
    width: 6px;
  }

  #collapsed-view-content::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }

  #collapsed-view-content::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
  }

  #collapsed-view-content::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }

  /* Enhanced truncation styles for collapsed view */
  .collapsed-issue-text {
    display: inline-block;
    max-width: 200px;
    /* Force maximum width */
    position: relative;
    cursor: help;
    white-space: nowrap;
    /* Prevent wrapping */
    overflow: hidden;
    /* Hide overflow */
    text-overflow: ellipsis;
    /* Add ellipsis for any remaining overflow */
  }

  .collapsed-issue-text.truncated {
    /* Visual indicator that text is truncated */
    opacity: 0.9;
    font-weight: 500;
  }

  /* Tooltip for full text on hover */
  .collapsed-issue-text[data-full-text]:hover::before {
    content: attr(data-full-text);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    line-height: 1.4;
    white-space: normal;
    word-break: break-word;
    max-width: 300px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    margin-bottom: 8px;
    opacity: 0;
    animation: tooltip-fade-in 0.2s ease-out forwards;
  }

  @keyframes tooltip-fade-in {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(4px);
    }

    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  /* Custom scrollbar styling for token view screens */
  #spacing-variables-content::-webkit-scrollbar,
  #colors-content::-webkit-scrollbar,
  #corner-radius-content::-webkit-scrollbar {
    width: 6px;
  }

  #spacing-variables-content::-webkit-scrollbar-track,
  #colors-content::-webkit-scrollbar-track,
  #corner-radius-content::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }

  #spacing-variables-content::-webkit-scrollbar-thumb,
  #colors-content::-webkit-scrollbar-thumb,
  #corner-radius-content::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
  }

  #spacing-variables-content::-webkit-scrollbar-thumb:hover,
  #colors-content::-webkit-scrollbar-thumb:hover,
  #corner-radius-content::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }

  /* Hide sticky footer on other screens */
  .sticky-footer {
    display: none;
  }

  #home-screen.active .sticky-footer {
    display: block;
  }

  /* Responsive Design */
  @media (max-width: 480px) {
    body {
      padding: var(--spacing-3) 16px;
    }

    .title {
      font-size: var(--font-size-xl);
    }

    .btn,
    .primary-button,
    .secondary-button {
      padding: var(--spacing-3) var(--spacing-4);
    }

    .sticky-footer {
      padding: var(--spacing-3) 16px;
    }

    #home-screen {
      padding-bottom: 120px;
      /* Smaller space on mobile */
    }
  }
</style>

<!-- Export Screen -->
<div id="export-screen" class="screen"
  style="background-color: #1a1a24; color: white; min-height: 100vh; padding: 32px 16px;">
  <div style="max-width: 400px;">
    <!-- Main Content -->
    <div>
      <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 16px;">

        <h1 class="gradient-text" style="font-size: 20px; font-weight: 700; line-height: 1.2; margin: 0;">
          Library Export
        </h1>
      </div>

      <p style="color: #9ca3af; font-size: 14px; line-height: 1.5; margin-bottom: 24px;">
        To enable automatic style detection, run this step from your design system file.
      </p>

      <h2 style="font-size: 16px; font-weight: 600; margin-bottom: 12px; color: white;">Instructions</h2>

      <div class="section">
        <ol style="list-style: none; display: flex; flex-direction: column; gap: 12px; margin: 0;">
          <li>If you’re already there, click Export below.</li>
          <li>If not, open your design system file, launch this plugin, and return here to export the library.</li>
        </ol>
      </div>

      <div id="export-status"
        style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 8px; padding: 16px; margin-bottom: 24px; font-size: 14px; color: white;">
        Ready to export from: <strong id="file-name" style="color: #10B981;">Loading...</strong>
      </div>

      <div style="display: flex; gap: 12px;">
        <button id="cancel-export-btn"
          style="flex: 1; padding: 12px 16px; background: #374151; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px;"
          onmouseover="this.style.background='#4B5563'" onmouseout="this.style.background='#374151'">
          <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
          Cancel
        </button>
        <button id="export-btn"
          style="flex: 2; padding: 12px 16px; background: #10B981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px;"
          onmouseover="this.style.background='#059669'" onmouseout="this.style.background='#10B981'">
          <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M7 16a4 4 0 0 1-.88-7.903A5 5 0 1 1 15.9 6L16 6a5 5 0 0 1 1 9.9M9 19l3 3m0 0 3-3m-3 3V10" />
          </svg>
          Export Library
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Link Screen (No JSON files) -->
<div id="link-screen" class="screen"
  style="background-color: #1a1a24; color: white; min-height: 100vh; padding: 32px 16px;">
  <div style="max-width: 400px;">


    <!-- Main Content -->
    <div>
      <div style="display: flex; align-items: center;  margin-bottom: 16px;">
        <svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg"
          style="width: 50px; height: 50px; flex-shrink: 0;">
          <!-- 3x3 Grid of tokens - dots only, no background -->
          <!-- Grid spacing: 40px between centers, starting at x=88, y=88 -->
          <!-- Row 1 -->
          <circle cx="88" cy="88" r="12" fill="#8B5CF6" />
          <circle cx="128" cy="88" r="12" fill="#8B5CF6" />
          <circle cx="168" cy="88" r="12" fill="#8B5CF6" />
          <!-- Row 2 - middle circle offset/highlighted -->
          <circle cx="88" cy="128" r="12" fill="#8B5CF6" />
          <!-- Highlighted center token - hollow ring (10% larger: 13.2px) -->
          <circle cx="128" cy="128" r="13.2" fill="none" stroke="#8B5CF6" stroke-width="3" />
          <circle cx="168" cy="128" r="12" fill="#8B5CF6" />
          <!-- Row 3 -->
          <circle cx="88" cy="168" r="12" fill="#8B5CF6" />
          <circle cx="128" cy="168" r="12" fill="#8B5CF6" />
          <circle cx="168" cy="168" r="12" fill="#8B5CF6" />
          <!-- Optional: Add subtle depth with one offset token -->
          <!-- Bottom right token slightly elevated/offset -->
          <circle cx="170" cy="166" r="8" fill="#8B5CF6" opacity="0.5" />
        </svg>
        <h1 class="gradient-text" style="font-size: 24px; font-weight: 700; line-height: 1.2; margin-left: -6;">
          Kova Token Validator
        </h1>
      </div>

      <p style="color: #9ca3af; font-size: 14px; line-height: 1.5; margin-bottom: 24px;">
        Connect your design system to bring in official text styles and tokens — keeping every file consistent and
        production-ready.
      </p>

      <h2 style="font-size: 16px; font-weight: 600; margin-bottom: 12px; color: white;">How it works</h2>

      <p style="color: #9ca3af; font-size: 13px; line-height: 1.5; margin-bottom: 24px;">
        Kova Token Validator scans your published library to capture text styles and design tokens. When you return to
        your working file, it automatically recognizes and imports them for validation.
      </p>

      <!-- Tip Message -->
      <div
        style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 24px; font-size: 13px; line-height: 1.5;">
        <span style="color: white; display: flex; align-items: flex-start; gap: 8px;">
          <svg style="width: 16px; height: 16px; color: #8B5CF6; margin-top: 1px; flex-shrink: 0;" fill="none"
            stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
          <span><strong>Best results:</strong> Works with any design system, but performs best with Kova Foundation for
            full variable compatibility. <a href="https://pivens.figma.site" target="_blank"
              style="color: #8B5CF6; text-decoration: none; font-weight: 500;">Learn more →</a></span>
        </span>
      </div>

      <!-- Button -->
      <button id="large-add-button"
        style="width: 100%; background: #8b5cf6; color: white; font-weight: 600; padding: 16px 24px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; border: none; cursor: pointer; font-size: 14px;"
        onmouseover="this.style.background='#7c3aed'" onmouseout="this.style.background='#8b5cf6'">
        <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        Library Export
      </button>
    </div>
  </div>
</div>

<!-- Selection Screen (Has JSON files, none selected) -->
<div id="selection-screen" class="screen">
  <div class="header">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
      <svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" style="width: 32px; height: 32px; flex-shrink: 0;">
        <!-- 3x3 Grid of tokens - dots only, no background -->
        <!-- Grid spacing: 40px between centers, starting at x=88, y=88 -->
        <!-- Row 1 -->
        <circle cx="88" cy="88" r="12" fill="#8B5CF6" />
        <circle cx="128" cy="88" r="12" fill="#8B5CF6" />
        <circle cx="168" cy="88" r="12" fill="#8B5CF6" />
        <!-- Row 2 - middle circle offset/highlighted -->
        <circle cx="88" cy="128" r="12" fill="#8B5CF6" />
        <!-- Highlighted center token - hollow ring (10% larger: 13.2px) -->
        <circle cx="128" cy="128" r="13.2" fill="none" stroke="#8B5CF6" stroke-width="3" />
        <circle cx="168" cy="128" r="12" fill="#8B5CF6" />
        <!-- Row 3 -->
        <circle cx="88" cy="168" r="12" fill="#8B5CF6" />
        <circle cx="128" cy="168" r="12" fill="#8B5CF6" />
        <circle cx="168" cy="168" r="12" fill="#8B5CF6" />
        <!-- Optional: Add subtle depth with one offset token -->
        <!-- Bottom right token slightly elevated/offset -->
        <circle cx="170" cy="166" r="8" fill="#8B5CF6" opacity="0.5" />
      </svg>
      <h1 class="title" style="margin: 0; color: #8B5CF6;">Kova Token Validation</h1>
    </div>
    <p class="subtitle">Attach a design system to automatically import text styles and access design tokens.</p>
  </div>

  <div
    style="background: #F5F3FF; border: 1px solid #8B5CF6; border-radius: 8px; padding: 20px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(139, 92, 246, 0.1);">
    <div class="section">
      <div class="section-title" style="color: #8B5CF6;">Design System</div>
      <div class="subtitle">Select a design system to validate your design tokens against.</div>
      <div class="custom-dropdown" id="library-dropdown" style="margin-top: 8px;">
        <div class="dropdown-selected" id="library-selected">
          <span id="library-selected-text">Select a library...</span>
          <svg class="dropdown-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="m6 9 6 6 6-6" />
          </svg>
        </div>
        <div class="dropdown-options" id="library-options">
          <!-- Options will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <div style="display: flex; justify-content: flex-end; margin-top: 8px;">
      <button id="reset-libraries-btn"
        style="padding: 6px 12px; background: #8B5CF6; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px; transition: background-color 0.2s ease;"
        onmouseover="this.style.background='#7C3AED'" onmouseout="this.style.background='#8B5CF6'">
        <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
          <path d="M21 3v5h-5" />
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
          <path d="M8 16H3v5" />
        </svg>
        Reset
      </button>
    </div>
  </div>
</div>
</div>

<!-- Home Screen (Has JSON file selected) -->
<div id="home-screen" class="screen">
  <div class="header">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
      <svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" style="width: 32px; height: 32px; flex-shrink: 0;">
        <!-- 3x3 Grid of tokens - dots only, no background -->
        <!-- Grid spacing: 40px between centers, starting at x=88, y=88 -->
        <!-- Row 1 -->
        <circle cx="88" cy="88" r="12" fill="#8B5CF6" />
        <circle cx="128" cy="88" r="12" fill="#8B5CF6" />
        <circle cx="168" cy="88" r="12" fill="#8B5CF6" />
        <!-- Row 2 - middle circle offset/highlighted -->
        <circle cx="88" cy="128" r="12" fill="#8B5CF6" />
        <!-- Highlighted center token - hollow ring (10% larger: 13.2px) -->
        <circle cx="128" cy="128" r="13.2" fill="none" stroke="#8B5CF6" stroke-width="3" />
        <circle cx="168" cy="128" r="12" fill="#8B5CF6" />
        <!-- Row 3 -->
        <circle cx="88" cy="168" r="12" fill="#8B5CF6" />
        <circle cx="128" cy="168" r="12" fill="#8B5CF6" />
        <circle cx="168" cy="168" r="12" fill="#8B5CF6" />
        <!-- Optional: Add subtle depth with one offset token -->
        <!-- Bottom right token slightly elevated/offset -->
        <circle cx="170" cy="166" r="8" fill="#8B5CF6" opacity="0.5" />
      </svg>
      <h1 class="title" style="margin: 0; color: #8B5CF6;">Token Validation</h1>
    </div>
    <p class="subtitle">Attach a design system to automatically import text styles and access design tokens.</p>
  </div>

  <div
    style="background: #F5F3FF; border: 1px solid #8B5CF6; border-radius: 8px; padding: 20px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(139, 92, 246, 0.1);">
    <div class="section">
      <div class="section-title" style="color: #8B5CF6;">Design System:</div>
      <div class="subtitle">Select a design system to validate your design tokens against.</div>
      <div class="custom-dropdown attached" id="home-library-dropdown" style="margin-top: 8px;">
        <div class="dropdown-selected" id="home-library-selected">
          <span id="selected-library-name">No Library Selected</span>
          <svg class="dropdown-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="m6 9 6 6 6-6" />
          </svg>
        </div>
        <div class="dropdown-options" id="home-library-options">
          <!-- Options will be populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>

  <div class="section validation-section">
    <div class="validation-header">
      <div class="section-title">Validation Options</div>
      <div class="subtitle" style="margin-bottom: var(--spacing-4);">Select what you'd like to validate from your
        attached
        design system.</div>
    </div>

    <div class="validation-options-scroll" id="validation-options-scroll">

      <label class="checkbox-group" for="text-styles-checkbox">
        <input type="checkbox" id="text-styles-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="3" y="3" width="18" height="18" rx="3" fill="#3B82F6" opacity="0.1" />
              <path d="M7 7h10M7 12h7M7 17h4" stroke="#3B82F6" stroke-width="2" stroke-linecap="round" />
              <circle cx="18" cy="7" r="2" fill="#3B82F6" />
            </svg>
            Text Styles
          </div>
          <div class="checkbox-description">Validate text styles usage from the design system</div>
          <div class="checkbox-meta">
            <span class="count" id="text-styles-count">0 Styles Available</span>
            <a href="#" id="view-text-styles" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="spacing-checkbox">
        <input type="checkbox" id="spacing-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="4" y="4" width="6" height="6" rx="1" fill="#10B981" opacity="0.2" />
              <rect x="14" y="4" width="6" height="6" rx="1" fill="#10B981" opacity="0.2" />
              <rect x="4" y="14" width="6" height="6" rx="1" fill="#10B981" opacity="0.2" />
              <rect x="14" y="14" width="6" height="6" rx="1" fill="#10B981" opacity="0.2" />
              <path d="M11 7h2M11 17h2M7 11v2M17 11v2" stroke="#10B981" stroke-width="2" stroke-linecap="round" />
            </svg>
            Spacing
          </div>
          <div class="checkbox-description">Validate spacing tokens and layout consistency</div>
          <div class="checkbox-meta">
            <span class="count" id="spacing-variables-count">0 Variables Available</span>
            <a href="#" id="view-spacing-tokens" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="colors-checkbox">
        <input type="checkbox" id="colors-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <circle cx="12" cy="12" r="10" fill="url(#colorGradient)" />
              <circle cx="8" cy="8" r="2" fill="#FF6B6B" />
              <circle cx="16" cy="8" r="2" fill="#4ECDC4" />
              <circle cx="8" cy="16" r="2" fill="#45B7D1" />
              <circle cx="16" cy="16" r="2" fill="#96CEB4" />
              <defs>
                <linearGradient id="colorGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" style="stop-color:#FF6B6B;stop-opacity:0.1" />
                  <stop offset="100%" style="stop-color:#4ECDC4;stop-opacity:0.1" />
                </linearGradient>
              </defs>
            </svg>
            Colors
          </div>
          <div class="checkbox-description">Validate color token usage and consistency</div>
          <div class="checkbox-meta">
            <span class="count" id="colors-count">0 Colors Available</span>
            <a href="#" id="view-colors" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="corner-radius-checkbox">
        <input type="checkbox" id="corner-radius-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="4" y="4" width="16" height="16" rx="2" fill="#F59E0B" opacity="0.1" stroke="#F59E0B"
                stroke-width="2" />
              <rect x="6" y="6" width="4" height="4" rx="1" fill="#F59E0B" opacity="0.3" />
              <rect x="14" y="6" width="4" height="4" rx="2" fill="#F59E0B" opacity="0.5" />
              <rect x="6" y="14" width="4" height="4" rx="0.5" fill="#F59E0B" opacity="0.3" />
              <rect x="14" y="14" width="4" height="4" rx="3" fill="#F59E0B" opacity="0.7" />
            </svg>
            Corner Radius
          </div>
          <div class="checkbox-description">Validate border radius tokens and consistency</div>
          <div class="checkbox-meta">
            <span class="count" id="corner-radius-count">0 Radius Tokens Available</span>
            <a href="#" id="view-corner-radius" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="typography-checkbox">
        <input type="checkbox" id="typography-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="2" y="2" width="20" height="20" rx="3" fill="#8B5CF6" opacity="0.1" />
              <text x="12" y="9" text-anchor="middle" fill="#8B5CF6" font-size="8" font-weight="bold">Aa</text>
              <rect x="4" y="12" width="16" height="2" rx="1" fill="#8B5CF6" opacity="0.3" />
              <rect x="4" y="16" width="12" height="1.5" rx="0.75" fill="#8B5CF6" opacity="0.5" />
              <rect x="4" y="19" width="8" height="1" rx="0.5" fill="#8B5CF6" opacity="0.4" />
            </svg>
            Typography
          </div>
          <div class="checkbox-description">Validate font sizes, weights, and line heights</div>
          <div class="checkbox-meta">
            <span class="count" id="typography-count">0 Typography Tokens Available</span>
            <a href="#" id="view-typography" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="shadows-checkbox">
        <input type="checkbox" id="shadows-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="6" y="6" width="10" height="10" rx="2" fill="#6B7280" opacity="0.2" />
              <rect x="4" y="4" width="10" height="10" rx="2" fill="#EF4444" opacity="0.1" stroke="#EF4444"
                stroke-width="1" />
              <rect x="5" y="5" width="8" height="8" rx="1.5" fill="#EF4444" opacity="0.8" />
              <circle cx="7" cy="7" r="1" fill="#FFFFFF" opacity="0.6" />
            </svg>
            Shadows
          </div>
          <div class="checkbox-description">Validate shadow and elevation tokens</div>
          <div class="checkbox-meta">
            <span class="count" id="shadows-count">0 Shadow Tokens Available</span>
            <a href="#" id="view-shadows" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="borders-checkbox">
        <input type="checkbox" id="borders-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="4" y="4" width="16" height="16" rx="2" fill="#06B6D4" opacity="0.1" />
              <rect x="4" y="4" width="16" height="16" rx="2" stroke="#06B6D4" stroke-width="2"
                stroke-dasharray="2,2" />
              <rect x="6" y="6" width="12" height="12" rx="1" stroke="#06B6D4" stroke-width="1" />
              <rect x="8" y="8" width="8" height="8" rx="1" stroke="#06B6D4" stroke-width="3" />
            </svg>
            Borders
          </div>
          <div class="checkbox-description">Validate border width and style tokens</div>
          <div class="checkbox-meta">
            <span class="count" id="borders-count">0 Border Tokens Available</span>
            <a href="#" id="view-borders" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="opacity-checkbox">
        <input type="checkbox" id="opacity-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <circle cx="12" cy="12" r="8" fill="#EC4899" opacity="1" />
              <circle cx="12" cy="12" r="6" fill="#EC4899" opacity="0.7" />
              <circle cx="12" cy="12" r="4" fill="#EC4899" opacity="0.4" />
              <circle cx="12" cy="12" r="2" fill="#EC4899" opacity="0.2" />
              <text x="12" y="13" text-anchor="middle" fill="white" font-size="6" font-weight="bold">%</text>
            </svg>
            Opacity
          </div>
          <div class="checkbox-description">Validate opacity and transparency tokens</div>
          <div class="checkbox-meta">
            <span class="count" id="opacity-count">0 Opacity Tokens Available</span>
            <a href="#" id="view-opacity" class="link">View Tokens</a>
          </div>
        </div>
      </label>

      <label class="checkbox-group" for="sizing-checkbox">
        <input type="checkbox" id="sizing-checkbox">
        <div class="checkbox-content">
          <div class="checkbox-title">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
              style="display: inline-block; margin-right: 8px;">
              <rect x="3" y="3" width="18" height="18" rx="2" fill="#14B8A6" opacity="0.1" stroke="#14B8A6"
                stroke-width="1" />
              <path d="M8 12h8M12 8v8" stroke="#14B8A6" stroke-width="2" stroke-linecap="round" />
              <path d="M6 6l2 2M18 6l-2 2M6 18l2-2M18 18l-2-2" stroke="#14B8A6" stroke-width="1.5"
                stroke-linecap="round" />
              <circle cx="12" cy="12" r="1.5" fill="#14B8A6" />
            </svg>
            Sizing
          </div>
          <div class="checkbox-description">Validate width, height, and dimension tokens</div>
          <div class="checkbox-meta">
            <span class="count" id="sizing-count">0 Sizing Tokens Available</span>
            <a href="#" id="view-sizing" class="link">View Tokens</a>
          </div>
        </div>
      </label>

    </div> <!-- End validation-options-scroll -->
  </div>

  <!-- Sticky Footer for Home Screen -->
  <div class="sticky-footer" id="home-sticky-footer">
    <div class="footer-tip">
      💡 <strong>Tip:</strong> Select a frame to validate specific content, or run validation without selection to check
      the entire page.
    </div>
    <button id="run-validation" class="primary-button" disabled>
      Run Validation
    </button>
  </div>
</div>

<!-- Hidden for now -->
<button id="apply" class="primary-button" style="display: none;">
  <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M5 13l4 4L19 7" />
  </svg>
  Apply to Selected Text
</button>
</div>

<!-- Export Instructions Screen -->
<div id="export-instructions-screen" class="screen"
  style="background: radial-gradient(ellipse 800px 600px at 50% 40%, hsl(262 70% 15% / 0.3) 0%, transparent 50%), linear-gradient(135deg, hsl(248 40% 6%) 0%, hsl(252 35% 8%) 50%, hsl(248 40% 6%) 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 2rem;">

  <!-- Content -->
  <div style="width: 100%; max-width: 28rem;">
    <div style="margin-bottom: 1.5rem;">
      <h1 class="gradient-text" style="font-size: 24px; font-weight: bold; margin-bottom: 0.5rem;">Export Library
        Styles</h1>
      <p style="font-size: 14px; color: hsl(240 5% 65%); line-height: 1.5;">Follow the steps below to prepare your
        design system for validation.</p>
    </div>

    <div style="margin-bottom: 1.5rem;">
      <h2 style="font-size: 1.125rem; font-weight: 600; color: hsl(0 0% 98%); margin-bottom: 0.75rem;">Instructions</h2>
      <ol style="list-style: none; display: flex; flex-direction: column; gap: 0.75rem;">
        <li style="display: flex; gap: 0.5rem; font-size: 0.875rem; color: hsl(240 5% 65%);">
          <span style="font-weight: 600; color: hsl(0 0% 98%);">1.</span>
          <span>
            <span style="font-weight: 600; color: hsl(0 0% 98%);">Go to your Design System Figma file</span> (the file
            containing your text styles)
          </span>
        </li>
        <li style="display: flex; gap: 0.5rem; font-size: 0.875rem; color: hsl(240 5% 65%);">
          <span style="font-weight: 600; color: hsl(0 0% 98%);">2.</span>
          <span>
            <span style="font-weight: 600; color: hsl(0 0% 98%);">Launch this plugin</span> in that file
          </span>
        </li>
      </ol>
    </div>

    <div
      style="background: hsl(262 83% 58% / 0.1); border: 1px solid hsl(262 83% 58% / 0.4); border-radius: 0.5rem; padding: 1rem; display: flex; gap: 0.75rem; margin-bottom: 1.5rem;">
      <svg style="width: 1.25rem; height: 1.25rem; color: hsl(262 83% 58%); flex-shrink: 0; margin-top: 0.125rem;"
        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
        <line x1="12" y1="9" x2="12" y2="13"></line>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
      <div style="font-size: 0.775rem; color: hsl(0 0% 98%);">
        <span style="font-weight: 600;">Tip:</span> Make sure you're in your main Design System file that contains all
        your published text styles before running the export.
      </div>
    </div>

    <button id="got-it-btn"
      style="width: 100%; height: 3.5rem; font-size: 14px; font-weight: 600; background: hsl(262 83% 58%); color: white; border: none; border-radius: 0.75rem; cursor: pointer; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); transition: all 0.2s;"
      onmouseover="this.style.background='hsl(262 83% 52%)'; this.style.boxShadow='0 20px 25px -5px rgba(0, 0, 0, 0.3)'"
      onmouseout="this.style.background='hsl(262 83% 58%)'; this.style.boxShadow='0 10px 15px -3px rgba(0, 0, 0, 0.3)'">
      Got It - I'll Go to My Design System File
    </button>
  </div>

</div>

<!-- Text Styles View Screen -->
<div id="text-styles-view-screen"
  style="position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: white; transition: left 0.3s ease; z-index: 10; overflow: hidden; padding: 16px; box-sizing: border-box;">
  <div class="header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
    <button id="back-to-home"
      style="background: none; border: none; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;">
      <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path d="M19 12H5m7-7l-7 7 7 7" />
      </svg>
      Back
    </button>

  </div>

  <div id="text-styles-content" style="height: calc(100% - 60px); overflow-y: auto;">
    <!-- Text styles will be populated here -->
  </div>
</div>

<!-- Colors View Screen -->
<div id="colors-view-screen"
  style="position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: white; transition: left 0.3s ease; z-index: 10; overflow: hidden; padding: 16px; box-sizing: border-box;">
  <div class="header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
    <button id="back-to-home-from-colors"
      style="background: none; border: none; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;">
      <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path d="M19 12H5m7-7l-7 7 7 7" />
      </svg>
      Back
    </button>
    <h2 style="margin: 0; font-size: 18px; font-weight: 600; color: #333;">Color Tokens</h2>
  </div>

  <div id="colors-content" style="height: calc(100% - 60px); overflow-y: auto;">
    <!-- Colors will be populated here -->
  </div>
</div>

<!-- Corner Radius View Screen -->
<div id="corner-radius-view-screen"
  style="position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: white; transition: left 0.3s ease; z-index: 10; overflow: hidden; padding: 16px; box-sizing: border-box;">
  <div class="header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
    <button id="back-to-home-from-corner-radius"
      style="background: none; border: none; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;">
      <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path d="M19 12H5m7-7l-7 7 7 7" />
      </svg>
      Back
    </button>
    <h2 style="margin: 0; font-size: 18px; font-weight: 600; color: #333;">Corner Radius Tokens</h2>
  </div>

  <div id="corner-radius-content" style="height: calc(100% - 60px); overflow-y: auto;">
    <!-- Corner radius tokens will be populated here -->
  </div>
</div>

<!-- Spacing Variables View Screen -->
<div id="spacing-variables-view-screen"
  style="position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: white; transition: left 0.3s ease; z-index: 10; overflow: hidden; padding: 16px; box-sizing: border-box;">
  <div class="header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
    <button id="back-to-home-from-spacing"
      style="background: none; border: none; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;">
      <svg class="icon icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path d="M19 12H5m7-7l-7 7 7 7" />
      </svg>
      Back
    </button>

  </div>

  <div id="spacing-variables-content" style="height: calc(100% - 60px); overflow-y: auto;">
    <!-- Spacing variables will be populated here -->
  </div>
</div>

<!-- Validation Results Screen -->
<div id="validation-results-screen" class="screen">
  <div style="background: white; min-height: 100vh;">
    <!-- Header with tab groups -->
    <div style="background: white; border-bottom: 1px solid #e5e7eb;">
      <div style="display: flex; align-items: center; padding: 16px 24px 16px 24px; max-width: 1200px; margin: 0 auto;">
        <!-- Left side: Category and Status tabs close together -->
        <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
          <!-- Category tabs -->
          <div id="category-tabs"
            style="display: flex; align-items: center; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 6px; padding: 2px;">
            <!-- Dynamic tabs will be inserted here -->
          </div>

          <!-- Vertical separator -->
          <div style="width: 1px; height: 20px; background: #e5e7eb;"></div>

          <!-- Status tabs -->
          <div id="status-tabs"
            style="display: flex; align-items: center; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 6px; padding: 2px;">
            <button id="active-tab" class="status-tab-button active" data-status="active">
              Active (0)
            </button>
            <button id="resolved-tab" class="status-tab-button" data-status="resolved">
              Resolved (0)
            </button>
            <button id="ignored-tab" class="status-tab-button" data-status="ignored">
              Ignored (0)
            </button>
          </div>
        </div>

        <!-- Action buttons (right) -->
        <div style="display: flex; align-items: center; gap: 2px;">
          <button id="minimize-btn"
            style="padding: 4px; background: transparent; border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.15s;"
            title="Minimize">
            <svg style="width: 14px; height: 14px; color: #6b7280;" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path d="M6 12h12" stroke-width="2" stroke-linecap="round" />
            </svg>
          </button>
          <button id="hamburger-menu-btn"
            style="padding: 4px; background: transparent; border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.15s;"
            title="Menu">
            <svg style="width: 14px; height: 14px; color: #6b7280;" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path d="M3 12h18M3 6h18M3 18h18" stroke-width="2" stroke-linecap="round" />
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Issues count header -->
    <div style="background: white; border-bottom: 1px solid #e5e7eb;">
      <div style="max-width: 1200px; margin: 0 auto; padding: 12px 24px;">
        <h2 id="issues-count" style="font-size: 15px; font-weight: 600; color: #111827; margin: 0;">Found 0 issues</h2>
      </div>
    </div>

    <!-- Results List -->
    <div style="background: white;">
      <div style="max-width: 1200px; margin: 0 auto;">
        <div id="validation-results-content"
          style="min-height: calc(100vh - 120px); max-height: calc(100vh - 120px); overflow-y: auto; padding-bottom: 20px;">
        </div>
        <!-- Validation items will be populated here by JavaScript -->
      </div>
    </div>

    <!-- Collapsed View Content (shown when minimized and node is selected) -->
    <div id="collapsed-view-content"
      style="display: none; background: white; max-height: calc(100vh - 200px); overflow-y: auto; min-height: 200px; padding: 0;">
      <div id="selected-node-issues" style="width: 100%;">
        <!-- Selected node issues will be shown here -->
      </div>
    </div>
  </div>


</div>
</div>

<!-- Export Confirmation Screen -->
<div id="export-confirmation-screen" class="screen"
  style="background-color: #1a1a24; color: white; min-height: 100vh; padding: 32px 16px;">
  <div style="max-width: 400px;">

    <!-- Main Content -->
    <div>
      <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 16px;">

        <h1 class="gradient-text" style="font-size: 20px; font-weight: 700; line-height: 1.2; margin: 0;">
          Library Export Complete
        </h1>
      </div>

      <p style="color: #9ca3af; font-size: 14px; line-height: 1.5; margin-bottom: 24px;">
        Your design system has been successfully exported and is ready to use.
      </p>

      <div
        style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 8px; padding: 16px; margin-bottom: 24px; display: flex; align-items: flex-start; gap: 12px;">
        <svg style="width: 20px; height: 20px; color: #10B981; margin-top: 2px; flex-shrink: 0;" fill="none"
          stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <div style="color: white;">
          <div style="font-weight: 600; margin-bottom: 4px;">Export Successful!</div>
          <div id="export-details" style="color: #9ca3af; font-size: 14px;">Your library has been exported and saved.
          </div>
        </div>
      </div>

      <h2 style="font-size: 16px; font-weight: 600; margin-bottom: 12px; color: white;">Next Steps</h2>

      <p style="color: #9ca3af; font-size: 14px; line-height: 1.5; margin-bottom: 24px;">
        Now you can return to your design files and use Kova Token Validation to ensure your designs match your
        exported library standards.
      </p>

      <button id="return-to-files"
        style="width: 100%; padding: 12px 16px; background: #8B5CF6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px;"
        onmouseover="this.style.background='#7C3AED'" onmouseout="this.style.background='#8B5CF6'">
        <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M9 11H3m0 0l3-3m-3 3l3 3m8-9l3 3m-3-3v12" />
        </svg>
        Return to Design Files
      </button>
    </div>
  </div>
</div></svg></button>

<!-- Kova Loading Component -->
<div id="kova-loader" class="kova-loader">
  <div class="kova-loader-container">
    <div class="kova-logo-wrapper">
      <svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" class="kova-logo-svg">
        <!-- Row 1 -->
        <circle cx="88" cy="88" r="12" fill="currentColor" />
        <circle cx="128" cy="88" r="12" fill="currentColor" />
        <circle cx="168" cy="88" r="12" fill="currentColor" />
        <!-- Row 2 - middle circle hollow -->
        <circle cx="88" cy="128" r="12" fill="currentColor" />
        <circle cx="128" cy="128" r="13.2" fill="none" stroke="currentColor" stroke-width="3" />
        <circle cx="168" cy="128" r="12" fill="currentColor" />
        <!-- Row 3 -->
        <circle cx="88" cy="168" r="12" fill="currentColor" />
        <circle cx="128" cy="168" r="12" fill="currentColor" />
        <circle cx="168" cy="168" r="12" fill="currentColor" />
        <!-- Offset token -->
        <circle cx="170" cy="166" r="8" fill="currentColor" opacity="0.5" />
      </svg>
    </div>
    <h1 class="kova-logo-text">Kova</h1>
    <div class="kova-loading-dots">
      <div class="kova-dot"></div>
      <div class="kova-dot"></div>
      <div class="kova-dot"></div>
    </div>
    <p class="kova-loading-text" id="kova-loading-text">Loading your design system...</p>
  </div>
</div>

<script>
  // Font loading and error handling
  // Loading state management
  let loadingStartTime = Date.now();
  let domLoaded = false;
  let fontsLoaded = false;
  let assetsLoaded = false;

  function checkAllLoaded() {
    const minLoadTime = 3000; // Minimum 3 seconds
    const elapsedTime = Date.now() - loadingStartTime;
    const remainingTime = Math.max(0, minLoadTime - elapsedTime);

    if (domLoaded && fontsLoaded && assetsLoaded) {
      setTimeout(() => {
        KovaLoader.hide();
        // Request UI mode after loader is hidden
        parent.postMessage({ pluginMessage: { type: 'get-ui-mode' } }, '*');
      }, remainingTime);
    }
  }

  document.addEventListener('DOMContentLoaded', function () {
    domLoaded = true;
    // Update loader message after DOM is ready
    KovaLoader.updateMessage('Loading your design system...');

    // Check if Inter font loaded successfully
    const testElement = document.createElement('div');
    testElement.style.fontFamily = 'Inter, sans-serif';
    testElement.style.position = 'absolute';
    testElement.style.visibility = 'hidden';
    testElement.textContent = 'Test';
    document.body.appendChild(testElement);

    const computedFont = window.getComputedStyle(testElement).fontFamily;
    if (!computedFont.includes('Inter')) {
      console.warn('Inter font failed to load, using system fonts');
      // Font fallback is already handled in CSS
    }

    document.body.removeChild(testElement);

    // Mark fonts as loaded and check if we can proceed
    fontsLoaded = true;
    checkAllLoaded();
  });

  // Check for other assets (images, etc.) - mark as loaded when window loads
  window.addEventListener('load', function () {
    assetsLoaded = true;
    KovaLoader.updateMessage('Initializing...');
    checkAllLoaded();
  });

  // Show loader immediately when script loads
  document.getElementById('kova-loader')?.classList.add('active', 'dark');

  // Kova Loading Component Functions
  window.KovaLoader = {
    show: function (message = 'Loading your design system...', theme = 'dark') {
      const loader = document.getElementById('kova-loader');
      const loadingText = document.getElementById('kova-loading-text');
      if (loader) {
        if (loadingText) {
          loadingText.textContent = message;
        }
        // Set theme
        loader.classList.remove('light', 'dark');
        loader.classList.add(theme);
        loader.classList.add('active');
      }
    },

    showLight: function (message = 'Loading...') {
      this.show(message, 'light');
    },

    showDark: function (message = 'Loading your design system...') {
      this.show(message, 'dark');
    },

    hide: function () {
      const loader = document.getElementById('kova-loader');
      if (loader) {
        loader.classList.remove('active');
      }
    },

    updateMessage: function (message) {
      const loadingText = document.getElementById('kova-loading-text');
      if (loadingText) {
        loadingText.textContent = message;
      }
    },

    setTheme: function (theme) {
      const loader = document.getElementById('kova-loader');
      if (loader) {
        loader.classList.remove('light', 'dark');
        loader.classList.add(theme);
      }
    }
  };

  // Handle security policy violations gracefully
  window.addEventListener('securitypolicyviolation', function (event) {
    console.warn('Content Security Policy violation:', event.blockedURI);
    // Don't show error to user for font loading issues
    if (event.blockedURI && event.blockedURI.includes('fonts.googleapis.com')) {
      console.info('Google Fonts blocked by CSP, using fallback fonts');
    }
  });

  // Global error handler
  window.addEventListener('error', function (event) {
    console.error('UI Error:', event.error);
    // Don't crash the UI for non-critical errors
    event.preventDefault();
  });

  // Request UI mode on startup
  console.log('UI starting up, requesting mode...')

  // Ensure slide-in screens are hidden on startup
  const textStylesSlideScreen = document.getElementById('text-styles-view-screen')
  if (textStylesSlideScreen) {
    textStylesSlideScreen.style.left = '100%'
  }

  const spacingSlideScreen = document.getElementById('spacing-variables-view-screen')
  if (spacingSlideScreen) {
    spacingSlideScreen.style.left = '100%'
  }

  const colorsSlideScreen = document.getElementById('colors-view-screen')
  if (colorsSlideScreen) {
    colorsSlideScreen.style.left = '100%'
  }

  const cornerRadiusSlideScreen = document.getElementById('corner-radius-view-screen')
  if (cornerRadiusSlideScreen) {
    cornerRadiusSlideScreen.style.left = '100%'
  }

  // UI mode will be requested after loader finishes

  // Checkbox interaction for selected state styling
  function setupCheckboxInteractions() {
    const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]')

    checkboxes.forEach(checkbox => {
      const checkboxGroup = checkbox.closest('.checkbox-group')

      // Set initial state
      if (checkbox.checked) {
        checkboxGroup.classList.add('selected')
      }

      // Handle checkbox changes
      checkbox.addEventListener('change', function () {
        if (this.checked) {
          checkboxGroup.classList.add('selected')
        } else {
          checkboxGroup.classList.remove('selected')
        }
      })
    })
  }

  // Initialize checkbox interactions when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupCheckboxInteractions)
  } else {
    setupCheckboxInteractions()
  }

  // Custom Dropdown Component
  class CustomDropdown {
    constructor(element) {
      this.element = element
      this.selected = element.querySelector('.dropdown-selected')
      this.options = element.querySelector('.dropdown-options')

      // Find the text element - try different selectors based on the dropdown
      this.selectedText = element.querySelector('#selected-library-name') ||
        element.querySelector('#library-selected-text') ||
        element.querySelector('.dropdown-selected span')

      this.isOpen = false
      this.selectedValue = ''
      this.libraries = []

      this.init()
    }

    init() {
      // Click to toggle dropdown
      this.selected.addEventListener('click', (e) => {
        e.stopPropagation()
        this.toggle()
      })

      // Close dropdown when clicking outside
      document.addEventListener('click', () => {
        this.close()
      })

      // Prevent closing when clicking inside options
      this.options.addEventListener('click', (e) => {
        e.stopPropagation()
      })
    }

    toggle() {
      if (this.isOpen) {
        this.close()
      } else {
        this.open()
      }
    }

    open() {
      this.element.classList.add('open')
      this.isOpen = true
    }

    close() {
      this.element.classList.remove('open')
      this.isOpen = false
    }

    setLibraries(libraries) {
      this.libraries = libraries
      this.renderOptions()
    }

    renderOptions() {
      this.options.innerHTML = ''

      // Add default option
      const defaultOption = document.createElement('div')
      defaultOption.className = 'dropdown-option'
      defaultOption.textContent = 'Select a library...'
      defaultOption.dataset.value = ''
      defaultOption.addEventListener('click', () => this.selectOption('', 'Select a library...'))
      this.options.appendChild(defaultOption)

      // Add library options
      this.libraries.forEach(library => {
        const option = document.createElement('div')
        option.className = 'dropdown-option'
        option.innerHTML = library.name
        option.dataset.value = library.key
        option.addEventListener('click', () => this.selectOption(library.key, library.name))
        this.options.appendChild(option)
      })
    }

    selectOption(value, text) {
      this.selectedValue = value
      if (this.selectedText) {
        this.selectedText.innerHTML = text
      }

      // Update selected state
      this.options.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.classList.remove('selected')
      })

      const selectedOption = this.options.querySelector(`[data-value="${value}"]`)
      if (selectedOption) {
        selectedOption.classList.add('selected')
      }

      // Update attached state
      if (value) {
        this.element.classList.add('attached')
      } else {
        this.element.classList.remove('attached')
      }

      this.close()

      // Trigger library selection
      parent.postMessage({
        pluginMessage: {
          type: 'select-library',
          libraryKey: value || null
        }
      }, '*')
    }

    setValue(value, text) {
      this.selectedValue = value
      if (this.selectedText) {
        this.selectedText.textContent = text
      }

      if (value) {
        this.element.classList.add('attached')
      } else {
        this.element.classList.remove('attached')
      }

      // Update selected state in options
      this.options.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.classList.remove('selected')
      })

      const selectedOption = this.options.querySelector(`[data-value="${value}"]`)
      if (selectedOption) {
        selectedOption.classList.add('selected')
      }
    }
  }

  // Initialize custom dropdowns
  let homeLibraryDropdown = null
  let selectionLibraryDropdown = null

  // Validation Dropdown Component
  class ValidationDropdown {
    constructor(element, nodeId) {
      this.element = element
      this.nodeId = nodeId
      this.sanitizedNodeId = nodeId.replace(/[^a-zA-Z0-9-_]/g, '-')
      this.selected = element.querySelector('.dropdown-selected')
      this.options = element.querySelector('.dropdown-options')
      this.selectedText = element.querySelector(`#validation-text-${this.sanitizedNodeId}`)
      this.isOpen = false
      this.selectedValue = ''


      this.init()
    }

    init() {
      // Click to toggle dropdown
      this.selected.addEventListener('click', (e) => {
        e.stopPropagation()
        this.toggle()
      })

      // Close dropdown when clicking outside
      document.addEventListener('click', () => {
        this.close()
      })

      // Prevent closing when clicking inside options
      this.options.addEventListener('click', (e) => {
        e.stopPropagation()
      })
    }

    toggle() {
      if (this.isOpen) {
        this.close()
      } else {
        this.open()
      }
    }

    open() {
      // Close other validation dropdowns
      document.querySelectorAll('.validation-dropdown.open').forEach(dd => {
        dd.classList.remove('open')
      })

      this.element.classList.add('open')
      this.options.style.display = 'block'
      this.isOpen = true
    }

    close() {
      this.element.classList.remove('open')
      this.options.style.display = 'none'
      this.isOpen = false
    }

    setOptions(optionsArray) {
      console.log('ValidationDropdown setOptions called with:', optionsArray)
      this.options.innerHTML = ''

      // Add default option
      const defaultOption = document.createElement('div')
      defaultOption.className = 'dropdown-option'
      defaultOption.style.cssText = 'padding: var(--spacing-2) var(--spacing-3); cursor: pointer; font-size: 13px; color: var(--color-gray-700); transition: background-color 0.2s ease;'
      defaultOption.textContent = 'Select a style...'
      defaultOption.dataset.value = ''
      defaultOption.addEventListener('click', () => this.selectOption('', 'Select a style...'))
      defaultOption.addEventListener('mouseenter', () => defaultOption.style.background = 'var(--color-gray-50)')
      defaultOption.addEventListener('mouseleave', () => defaultOption.style.background = 'white')
      this.options.appendChild(defaultOption)

      // Add style options
      optionsArray.forEach(option => {
        const optionElement = document.createElement('div')
        optionElement.className = 'dropdown-option'
        optionElement.style.cssText = 'padding: var(--spacing-2) var(--spacing-3); cursor: pointer; font-size: 13px; color: var(--color-gray-700); transition: background-color 0.2s ease;'
        optionElement.textContent = option.text
        optionElement.dataset.value = option.value
        optionElement.addEventListener('click', () => this.selectOption(option.value, option.text))
        optionElement.addEventListener('mouseenter', () => optionElement.style.background = 'var(--color-gray-50)')
        optionElement.addEventListener('mouseleave', () => optionElement.style.background = 'white')
        this.options.appendChild(optionElement)
      })
    }

    selectOption(value, text) {
      this.selectedValue = value
      if (this.selectedText) {
        this.selectedText.textContent = text
      }

      // Update selected state
      this.options.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.style.background = 'white'
        opt.style.fontWeight = 'normal'
      })

      const selectedOption = this.options.querySelector(`[data-value="${value}"]`)
      if (selectedOption) {
        selectedOption.style.background = 'var(--color-primary-light)'
        selectedOption.style.color = 'var(--color-primary)'
        selectedOption.style.fontWeight = '600'
      }

      this.close()

      // Trigger update button state change
      this.updateButtonState()
    }

    updateButtonState() {
      const updateBtn = document.querySelector(`.update-btn[data-node-id="${this.nodeId}"]`)
      if (updateBtn) {
        if (this.selectedValue && this.selectedValue !== '') {
          // Enable update button - CSS classes handle the styling
          updateBtn.disabled = false
        } else {
          // Disable update button - CSS classes handle the styling
          updateBtn.disabled = true
        }
      }
    }

    getValue() {
      return this.selectedValue
    }
  }

  function initializeCustomDropdown() {
    const homeDropdownElement = document.getElementById('home-library-dropdown')
    if (homeDropdownElement && !homeLibraryDropdown) {
      homeLibraryDropdown = new CustomDropdown(homeDropdownElement)
    }

    const selectionDropdownElement = document.getElementById('library-dropdown')
    if (selectionDropdownElement && !selectionLibraryDropdown) {
      selectionLibraryDropdown = new CustomDropdown(selectionDropdownElement)
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCustomDropdown)
  } else {
    initializeCustomDropdown()
  }

  // Fallback: show home screen after a short delay if no screen is shown
  setTimeout(() => {
    const activeScreen = document.querySelector('.screen.active')
    if (!activeScreen) {
      console.log('No screen active, showing home screen as fallback')
      showScreen('home')
    }
  }, 1000)

  // Function to show only one screen
  function showScreen(mode) {
    console.log('🎬 showScreen called with mode:', mode)

    // Debug: Log currently active screens before hiding
    const currentlyActive = document.querySelectorAll('.screen.active')
    console.log('Currently active screens:', Array.from(currentlyActive).map(s => s.id))

    // AGGRESSIVELY hide all screens
    document.querySelectorAll('.screen').forEach(screen => {
      screen.classList.remove('active')
      screen.style.display = 'none' // Force hide with inline style
      console.log('🚫 Forcibly hidden screen:', screen.id)
    })

    // Small delay to ensure clearing is complete
    setTimeout(() => {

      // Show the requested screen
      const screenMap = {
        'export': 'export-screen',
        'link': 'link-screen',
        'selection': 'selection-screen',
        'home': 'home-screen',
        'export-instructions': 'export-instructions-screen',
        'export-confirmation': 'export-confirmation-screen',
        'validation-results': 'validation-results-screen'
      }

      const screenId = screenMap[mode]
      console.log('Mapped to screenId:', screenId)

      if (screenId) {
        const screen = document.getElementById(screenId)
        if (screen) {
          screen.classList.add('active')
          screen.style.display = 'block' // Force show with inline style
          console.log('✅ Successfully activated screen:', screenId)

          // Debug: Verify only one screen is active
          const allActiveScreens = document.querySelectorAll('.screen.active')
          console.log('All active screens after switch:', Array.from(allActiveScreens).map(s => s.id))
        } else {
          console.log('❌ Screen element not found:', screenId)
        }
      } else {
        console.log('❌ No mapping found for mode:', mode)
      }
    }, 50) // Close the setTimeout with 50ms delay
  }

  // Function to go back to home screen
  function goBackToHome() {
    parent.postMessage({
      pluginMessage: {
        type: 'back-to-validation'
      }
    }, '*')
    showScreen('home')
  }

  // Track successfully updated items
  window.updatedItems = window.updatedItems || new Set()

  // Visual feedback functions for applied styles
  function showStyleAppliedFeedback(nodeId, styleName, targetType, appliedCorners = null, isCornerRadius = false) {
    if (!nodeId) {
      // For selection-based applications, show a general success message
      showSuccessNotification('Updated')
      return
    }

    // For corner radius tokens, handle individual corner updates
    if (isCornerRadius && appliedCorners) {
      updateCornerRadiusStates(nodeId, appliedCorners)
      // Don't mark as resolved unless all corners have tokens
      const allCornersHaveTokens = checkIfAllCornersHaveTokens(nodeId)
      if (allCornersHaveTokens) {
        const issueStates = window.issueStates || new Map()
        issueStates.set(nodeId, 'resolved')
        window.issueStates = issueStates
      }
    } else {
      // For spacing and other tokens, store resolved state and mark as resolved
      if (targetType === 'node') {
        // Check if this is a spacing token by looking for spacing dropdown
        const spacingDropdown = document.querySelector(`.spacing-dropdown[data-node-id="${nodeId}"]`)
        if (spacingDropdown && spacingDropdown.selectedToken) {
          // Store resolved spacing state
          const resolvedStates = window.resolvedSpacingStates || new Map()
          resolvedStates.set(nodeId, {
            value: styleName, // The applied token name
            isToken: true
          })
          window.resolvedSpacingStates = resolvedStates
        }
      }

      // Mark as resolved in the issue states (don't add to updatedItems to keep it visible in resolved tab)
      const issueStates = window.issueStates || new Map()
      issueStates.set(nodeId, 'resolved')
      window.issueStates = issueStates
    }

    // Update tab counts immediately
    updateStatusTabCounts()
    updateCategoryTabCounts()

    // Find the validation item for this node
    const validationItem = document.querySelector(`[data-node-id="${nodeId}"]`)?.closest('div[style*="display: flex"]')
    const updateButton = document.querySelector(`button[data-node-id="${nodeId}"].update-btn`)

    // No visual styling needed for validation item during updates

    if (updateButton) {
      if (isCornerRadius && appliedCorners) {
        // For corner radius, only disable if all corners have tokens
        const allCornersHaveTokens = checkIfAllCornersHaveTokens(nodeId)
        if (allCornersHaveTokens) {
          // All corners have tokens, mark as complete
          updateButton.innerHTML = '<span class="btn-text">✓ Complete</span>'
          updateButton.classList.add('update-btn-success')
          updateButton.disabled = true

          setTimeout(() => {
            applyFilters() // This will move it to resolved tab
          }, 900)
        } else {
          // Some corners still need tokens - button state will be handled by updateCornerRadiusStates
          updateButton.innerHTML = '<span class="btn-text">Update</span>'
        }
      } else {
        // Transform the update button to show success for non-corner-radius items
        const originalText = updateButton.innerHTML
        updateButton.innerHTML = '<span class="btn-text">Update</span>'
        updateButton.classList.add('update-btn-success')
        updateButton.disabled = true

        // Show success state briefly, then refresh the view
        setTimeout(() => {
          // Refresh the current view to remove resolved items from active tab
          applyFilters()
        }, 900)
      }
    }

    // Show generic success notification
    showSuccessNotification('Updated')
  }

  function updateCornerRadiusStates(nodeId, appliedCorners) {
    // Update individual corner elements to show they now have tokens
    for (const [corner, tokenName] of Object.entries(appliedCorners)) {
      const cornerDropdown = document.querySelector(`.corner-radius-dropdown[data-node-id="${nodeId}"][data-corner="${corner}"]`)
      if (cornerDropdown) {
        // Replace the input/existing content with a token badge (state 1)
        const container = cornerDropdown.querySelector('div[title*="Design System Token"], div[style*="background: white"]')
        const input = cornerDropdown.querySelector('.corner-radius-input')

        if (container || input) {
          // Preserve the dropdown options
          const dropdownOptions = cornerDropdown.querySelector('.corner-dropdown-options')
          const dropdownOptionsHTML = dropdownOptions ? dropdownOptions.outerHTML : `
            <div class="corner-dropdown-options" style="position: absolute; top: 100%; left: 0; min-width: 120px; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
              <!-- Options will be populated by JavaScript -->
            </div>
          `

          // Create new token badge container (state 1)
          const newContent = `
            <div style="background: white; border: 1px solid #d1d5db; border-radius: 3px; padding: 4px; width: 40px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Design System Token: ${tokenName} (click to change)">
              <span class="corner-token-badge existing-token">${tokenName}</span>
            </div>
          `
          cornerDropdown.innerHTML = newContent + dropdownOptionsHTML

          // Clear selectedToken since this corner now has an applied token (existing token)
          // Only user-selected tokens should enable the update button
          cornerDropdown.selectedToken = null
          cornerDropdown.hasExistingToken = true
          cornerDropdown.existingTokenValue = tokenName

          // Reattach event handlers for the updated corner
          cornerDropdown.removeAttribute('data-handlers-attached')
        }
      }
    }

    // Update button state - check if any corners still have user-selected tokens
    const updateBtn = document.querySelector(`.update-btn[data-node-id="${nodeId}"]`)
    if (updateBtn) {
      const allCornerDropdowns = document.querySelectorAll(`.corner-radius-dropdown[data-node-id="${nodeId}"]`)
      const hasUserSelectedTokens = Array.from(allCornerDropdowns).some(d => d.selectedToken)

      if (hasUserSelectedTokens) {
        updateBtn.disabled = false
        updateBtn.style.background = '#3b82f6'
        updateBtn.style.color = 'white'
        updateBtn.style.cursor = 'pointer'
      } else {
        updateBtn.disabled = true
        updateBtn.style.background = '#f3f4f6'
        updateBtn.style.color = '#6b7280'
        updateBtn.style.cursor = 'not-allowed'
      }
    }

    // Check if all corners are now resolved after applying tokens
    checkAndResolveCornerRadiusItem(nodeId)

    // Reattach event handlers for updated corners
    setTimeout(() => {
      setupValidationEventHandlers()
    }, 100)

    // No visual animation needed - corners are already updated to show token state
  }

  function checkAndResolveCornerRadiusItem(nodeId) {
    // Check if all corners are now in a valid state (either have tokens or are 0)
    const corners = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']
    const allCornersValid = corners.every(corner => {
      const cornerDropdown = document.querySelector(`.corner-radius-dropdown[data-node-id="${nodeId}"][data-corner="${corner}"]`)
      if (!cornerDropdown) return false

      // Check if corner has any type of token badge (existing token or user-selected)
      const tokenBadge = cornerDropdown.querySelector('.corner-token-badge')
      if (tokenBadge) return true

      // Check if corner has hardcoded value 0 (which is not an issue)
      const input = cornerDropdown.querySelector('.corner-radius-input')
      if (input && input.value === '0') return true

      // Check if corner has existing token flag (from validation data)
      if (cornerDropdown.hasExistingToken) return true

      return false
    })

    if (allCornersValid) {
      console.log(`All corners for node ${nodeId} are now valid, marking as resolved`)

      // Store the current resolved state for display in resolved tab
      const resolvedStates = window.resolvedCornerStates || new Map()
      const cornerMap = {
        'topLeft': 'topLeftRadius',
        'topRight': 'topRightRadius',
        'bottomLeft': 'bottomLeftRadius',
        'bottomRight': 'bottomRightRadius'
      }

      const resolvedCornerValues = {}
      corners.forEach(corner => {
        const cornerDropdown = document.querySelector(`.corner-radius-dropdown[data-node-id="${nodeId}"][data-corner="${corner}"]`)
        const cornerKey = cornerMap[corner] || corner

        if (cornerDropdown) {
          // Check if corner has a token badge
          const tokenBadge = cornerDropdown.querySelector('.corner-token-badge')
          if (tokenBadge) {
            resolvedCornerValues[cornerKey] = {
              value: tokenBadge.textContent,
              hasToken: true
            }
          } else {
            // Check if corner has an input field (hardcoded value)
            const input = cornerDropdown.querySelector('.corner-radius-input')
            if (input && input.value) {
              resolvedCornerValues[cornerKey] = {
                value: input.value,
                hasToken: false // Hardcoded values (including 0) are not tokens
              }
            }
          }
        }
      })

      resolvedStates.set(nodeId, resolvedCornerValues)
      window.resolvedCornerStates = resolvedStates

      // Mark as resolved in the issue states
      const issueStates = window.issueStates || new Map()
      issueStates.set(nodeId, 'resolved')
      window.issueStates = issueStates

      // Update tab counts
      updateStatusTabCounts()
      updateCategoryTabCounts()

      // Refresh the view to move item to resolved tab
      setTimeout(() => {
        applyFilters()
      }, 500)

      // Show a more specific success message for resolution
      showSuccessNotification('Item resolved')
    }
  }

  function checkIfAllCornersHaveTokens(nodeId) {
    const corners = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']
    return corners.every(corner => {
      const cornerDropdown = document.querySelector(`.corner-radius-dropdown[data-node-id="${nodeId}"][data-corner="${corner}"]`)
      if (!cornerDropdown) return false

      // Check if this corner has a token badge (state 1)
      const tokenBadge = cornerDropdown.querySelector('.corner-token-badge.existing-token')
      return !!tokenBadge
    })
  }

  function showUpdateButtonLoading(button, styleName) {
    const nodeId = button.getAttribute('data-node-id')
    const validationItem = button.closest('div[style*="display: flex"]')

    // Remove the yellow background - no visual change to validation item during loading

    // Update button to show loading state
    button.innerHTML = `
      <div style="display: flex; align-items: center; gap: 6px;">
        <div style="width: 12px; height: 12px; border: 2px solid transparent; border-top: 2px solid currentColor; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        <span>Applying...</span>
      </div>
    `
    button.disabled = true
    button.style.opacity = '0.8'

    // Add spin animation if not already present
    if (!document.getElementById('spin-animation')) {
      const style = document.createElement('style')
      style.id = 'spin-animation'
      style.textContent = `
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `
      document.head.appendChild(style)
    }
  }

  function resetUpdateButton(nodeId) {
    const updateButton = document.querySelector(`button[data-node-id="${nodeId}"].update-btn`)
    if (updateButton) {
      updateButton.classList.remove('update-btn-success')
      updateButton.disabled = false
      updateButton.innerHTML = 'Update'
      updateButton.style.opacity = '1'
    }
  }

  function showSuccessNotification(message) {
    // Create or update success notification
    let notification = document.getElementById('success-notification')
    if (!notification) {
      notification = document.createElement('div')
      notification.id = 'success-notification'
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        z-index: 10000;
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        display: flex;
        align-items: center;
        gap: 8px;
      `
      document.body.appendChild(notification)
    }

    notification.innerHTML = `
      <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
      </svg>
      ${message}
    `

    // Show notification
    setTimeout(() => {
      notification.style.transform = 'translateX(0)'
    }, 100)

    // Hide notification after 3 seconds
    setTimeout(() => {
      notification.style.transform = 'translateX(100%)'
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification)
        }
      }, 300)
    }, 3000)
  }

  function updateCategoryTabCounts() {
    // Update category tab counts based on current status filter
    const currentStatusFilter = window.currentStatusFilter || 'active'
    const allResults = window.validationResults || []
    const issueStates = window.issueStates || new Map()

    // Filter results by current status
    const statusFilteredResults = allResults.filter(result => {
      const nodeId = result.node?.id
      const issueState = nodeId ? (issueStates.get(nodeId) || 'active') : 'active'
      return issueState === currentStatusFilter
    })

    // Update "All" tab for current status
    const allTab = document.getElementById('all-tab')
    if (allTab) allTab.textContent = `All (${statusFilteredResults.length})`

    // Update category tabs for current status
    const categoryTabs = document.querySelectorAll('.category-tab-button:not(#all-tab)')
    categoryTabs.forEach(tab => {
      const tabType = tab.dataset.tab
      const itemsOfType = statusFilteredResults.filter(result => result.type === tabType)

      // Extract the label from the current tab text
      const currentText = tab.textContent
      const labelMatch = currentText.match(/^(.+?)\s*\(\d+\)$/)
      const label = labelMatch ? labelMatch[1] : tabType

      tab.textContent = `${label} (${itemsOfType.length})`
    })
  }

  function updateValidationCounts() {
    // Use the new status-aware counting system
    updateStatusTabCounts()
    updateCategoryTabCounts()

    // Check if current status has no issues for success message
    const currentStatusFilter = window.currentStatusFilter || 'active'
    const allResults = window.validationResults || []
    const issueStates = window.issueStates || new Map()

    const statusFilteredResults = allResults.filter(result => {
      const nodeId = result.node?.id
      const issueState = nodeId ? (issueStates.get(nodeId) || 'active') : 'active'
      return issueState === currentStatusFilter
    })

    if (statusFilteredResults.length === 0 && currentStatusFilter === 'active') {
      const content = document.getElementById('validation-results-content')
      if (content) {
        content.innerHTML = `
          <div style="text-align: center; padding: 40px 16px; color: #28a745;">
            <div style="font-size: 32px; margin-bottom: 12px;">🎉</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 6px; color: #111827;">All Issues Resolved!</div>
            <div style="font-size: 14px; color: #6b7280;">Your design is now compliant with the design system.</div>
          </div>
        `
      }
    }
  }

  // Export screen handlers
  const exportBtn = document.getElementById('export-btn')
  if (exportBtn) {
    exportBtn.onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'export-keys' } }, '*')
    }
  }

  const cancelExportBtn = document.getElementById('cancel-export-btn')
  if (cancelExportBtn) {
    cancelExportBtn.onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'cancel-export-instructions' } }, '*')
    }
  }

  // Link screen handlers
  const largeAddBtn = document.getElementById('large-add-button')
  if (largeAddBtn) {
    largeAddBtn.onclick = () => {
      parent.postMessage({
        pluginMessage: {
          type: 'switch-mode',
          mode: 'export-instructions'
        }
      }, '*')
    }
  }

  // Selection screen handlers - now handled by custom dropdown

  // Home screen handlers
  document.getElementById('apply').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'apply-text-style', styleName: 'Display/Large' } }, '*')
  }

  // Validation option handlers
  function updateRunValidationButton() {
    const checkboxes = [
      'text-styles-checkbox',
      'spacing-checkbox',
      'colors-checkbox',
      'corner-radius-checkbox',
      'typography-checkbox',
      'shadows-checkbox',
      'borders-checkbox',
      'opacity-checkbox',
      'sizing-checkbox'
    ]

    const anyChecked = checkboxes.some(id => {
      const checkbox = document.getElementById(id)
      const checkboxGroup = document.querySelector(`label[for="${id}"]`)
      // Only count checkboxes that are visible and checked
      return checkbox && checkbox.checked && checkboxGroup && checkboxGroup.style.display !== 'none'
    })

    const runButton = document.getElementById('run-validation')
    if (runButton) {
      if (anyChecked) {
        runButton.disabled = false
        runButton.style.background = '#4CAF50'
        runButton.style.cursor = 'pointer'
      } else {
        runButton.disabled = true
        runButton.style.background = '#999'
        runButton.style.cursor = 'not-allowed'
      }
    }
  }

  // Add event listeners for all validation checkboxes
  const validationCheckboxIds = [
    'text-styles-checkbox',
    'spacing-checkbox',
    'colors-checkbox',
    'corner-radius-checkbox',
    'typography-checkbox',
    'shadows-checkbox',
    'borders-checkbox',
    'opacity-checkbox',
    'sizing-checkbox'
  ]

  validationCheckboxIds.forEach(id => {
    const checkbox = document.getElementById(id)
    if (checkbox) {
      checkbox.onchange = updateRunValidationButton
    }
  })

  // Ensure the button exists before attaching handler
  const runValidationBtn = document.getElementById('run-validation')
  if (runValidationBtn) {
    console.log('✅ Run validation button found and handler attached')
    runValidationBtn.onclick = () => {
      console.log('🔥 Run validation button clicked!')
      console.log('Button disabled state:', runValidationBtn.disabled)

      if (!runValidationBtn.disabled) {
        console.log('Running validation...')

        // Check which validation options are selected (only visible ones)
        const getVisibleCheckboxValue = (checkboxId) => {
          const checkbox = document.getElementById(checkboxId)
          const checkboxGroup = document.querySelector(`label[for="${checkboxId}"]`)
          // Only return true if checkbox is checked AND visible
          return checkbox && checkbox.checked && checkboxGroup && checkboxGroup.style.display !== 'none'
        }

        const validationOptions = {
          textStyles: getVisibleCheckboxValue('text-styles-checkbox'),
          spacing: getVisibleCheckboxValue('spacing-checkbox'),
          colors: getVisibleCheckboxValue('colors-checkbox'),
          cornerRadius: getVisibleCheckboxValue('corner-radius-checkbox'),
          typography: getVisibleCheckboxValue('typography-checkbox'),
          shadows: getVisibleCheckboxValue('shadows-checkbox'),
          borders: getVisibleCheckboxValue('borders-checkbox'),
          opacity: getVisibleCheckboxValue('opacity-checkbox'),
          sizing: getVisibleCheckboxValue('sizing-checkbox')
        }

        // Check if at least one visible option is selected
        const hasSelection = Object.values(validationOptions).some(checked => checked)
        if (!hasSelection) {
          alert('Please select at least one validation option.')
          return
        }

        // Backward compatibility - keep existing variables
        const textStylesChecked = validationOptions.textStyles
        const spacingChecked = validationOptions.spacing

        // Show validation results screen immediately
        showScreen('validation-results')

        // Tell plugin to resize for validation results
        parent.postMessage({
          pluginMessage: {
            type: 'switch-mode',
            mode: 'validation-results'
          }
        }, '*')

        // Add loading message with progress indicator
        const content = document.getElementById('validation-results-content')
        if (content) {
          content.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #666;">
            <div style="font-size: 18px; margin-bottom: 16px;">🔍 Running validation...</div>
            <div style="width: 200px; height: 4px; background: #e0e0e0; border-radius: 2px; margin: 0 auto; overflow: hidden;">
              <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #10b981, #059669); animation: progress 2s ease-in-out infinite;"></div>
            </div>
            <div style="margin-top: 16px; font-size: 14px; color: #999;">This may take a few moments...</div>
          </div>
          <style>
            @keyframes progress {
              0% { transform: translateX(-100%); }
              100% { transform: translateX(100%); }
            }
          </style>
        `
        }

        // Send validation request to plugin
        console.log('🚀 Sending validation request with options:', validationOptions)
        parent.postMessage({
          pluginMessage: {
            type: 'run-validation',
            options: validationOptions
          }
        }, '*')
      }
    }
  } else {
    console.log('❌ Run validation button not found during initial setup')
    // Try again after a delay
    setTimeout(() => {
      const delayedBtn = document.getElementById('run-validation')
      if (delayedBtn) {
        console.log('✅ Run validation button found on retry')
        delayedBtn.onclick = () => {
          console.log('🔥 Run validation button clicked (delayed handler)!')
          if (!delayedBtn.disabled) {
            // Trigger validation
            parent.postMessage({
              pluginMessage: {
                type: 'run-validation',
                options: {
                  textStyles: document.getElementById('text-styles-checkbox')?.checked || false,
                  spacing: document.getElementById('spacing-checkbox')?.checked || false
                }
              }
            }, '*')
            showScreen('validation-results')
          }
        }
      }
    }, 1000)
  }

  // Reset button handler
  const resetBtn = document.getElementById('reset-libraries-btn')
  if (resetBtn) {
    resetBtn.onclick = () => {
      if (confirm('Are you sure you want to delete all saved design systems? This cannot be undone.')) {
        parent.postMessage({ pluginMessage: { type: 'clear-all-libraries' } }, '*')
      }
    }
  }

  // Text styles view handlers
  document.getElementById('view-text-styles').onclick = (e) => {
    e.preventDefault()

    // Show loading state immediately
    const slideScreen = document.getElementById('text-styles-view-screen')
    const content = document.getElementById('text-styles-content')

    content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">Loading text styles...</div>'
    slideScreen.style.left = '0'

    // Request text styles data
    parent.postMessage({ pluginMessage: { type: 'get-text-styles' } }, '*')
  }

  document.getElementById('back-to-home').onclick = () => {
    // Hide slide-in screen
    const slideScreen = document.getElementById('text-styles-view-screen')
    slideScreen.style.left = '100%'

    // Show the validation footer again
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'block'
    }
  }

  document.getElementById('back-to-home-from-spacing').onclick = () => {
    // Hide slide-in screen
    const slideScreen = document.getElementById('spacing-variables-view-screen')
    slideScreen.style.left = '100%'

    // Show the validation footer again
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'block'
    }
  }

  // Colors view handlers
  document.getElementById('view-colors').onclick = (e) => {
    e.preventDefault()

    // Show loading state immediately
    const slideScreen = document.getElementById('colors-view-screen')
    const content = document.getElementById('colors-content')

    content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">Loading color tokens...</div>'
    slideScreen.style.left = '0'

    // Request colors data
    parent.postMessage({ pluginMessage: { type: 'get-colors' } }, '*')
  }

  document.getElementById('back-to-home-from-colors').onclick = () => {
    // Hide slide-in screen
    const slideScreen = document.getElementById('colors-view-screen')
    slideScreen.style.left = '100%'

    // Show the validation footer again
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'block'
    }
  }

  // Corner Radius view handlers
  document.getElementById('view-corner-radius').onclick = (e) => {
    e.preventDefault()

    // Show loading state immediately
    const slideScreen = document.getElementById('corner-radius-view-screen')
    const content = document.getElementById('corner-radius-content')

    content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">Loading corner radius tokens...</div>'
    slideScreen.style.left = '0'

    // Request corner radius data
    parent.postMessage({ pluginMessage: { type: 'get-corner-radius' } }, '*')
  }

  document.getElementById('back-to-home-from-corner-radius').onclick = () => {
    // Hide slide-in screen
    const slideScreen = document.getElementById('corner-radius-view-screen')
    slideScreen.style.left = '100%'

    // Show the validation footer again
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'block'
    }
  }

  // Spacing variables view handlers
  document.getElementById('view-spacing-tokens').onclick = (e) => {
    e.preventDefault()

    // Show loading state immediately
    const slideScreen = document.getElementById('spacing-variables-view-screen')
    const content = document.getElementById('spacing-variables-content')

    content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">Loading spacing variables...</div>'
    slideScreen.style.left = '0'

    // Request spacing variables data
    parent.postMessage({ pluginMessage: { type: 'get-spacing-variables' } }, '*')
  }

  function showTextStylesScreen(textStyles) {
    // Hide the validation footer when viewing tokens
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'none'
    }

    const slideScreen = document.getElementById('text-styles-view-screen')
    const content = document.getElementById('text-styles-content')

    // Group styles by category (Body, Display, Headline, etc.)
    const groups = {}
    Object.entries(textStyles).forEach(([name, styleData]) => {
      const parts = name.split('/')
      const category = parts[0] || 'Other'
      const styleName = parts.slice(1).join('/') || name

      if (!groups[category]) {
        groups[category] = []
      }
      groups[category].push({
        name: styleName,
        fullName: name,
        data: styleData
      })
    })

    // Generate HTML for grouped styles
    let html = ''
    Object.entries(groups).forEach(([category, styles]) => {
      html += `<div class="text-style-group">
        <div class="text-style-group-title">${category}</div>`

      styles.forEach((style, index) => {
        const data = style.data
        const fontSize = data.fontSize !== undefined ? `${data.fontSize}px` : ''
        const fontInfo = data.fontFamily && data.fontWeight ?
          `${data.fontFamily} ${data.fontWeight}` : style.fullName
        const lineHeight = data.lineHeight && typeof data.lineHeight === 'object' && data.lineHeight.unit === 'PIXELS' ?
          `/${Math.round(data.lineHeight.value)}` :
          data.lineHeight && typeof data.lineHeight === 'object' && data.lineHeight.unit === 'PERCENT' ?
            `/${Math.round(data.fontSize * data.lineHeight.value / 100)}` : ''

        html += `<div class="text-style-item">
          <div class="text-style-info">
            <h4>${style.name}</h4>
            <p>${fontInfo}${lineHeight ? ` (${fontSize}${lineHeight})` : ''}</p>
          </div>
          <div class="text-style-size">${fontSize}</div>
        </div>`
      })

      html += '</div>'
    })

    content.innerHTML = html

    // Show slide-in screen
    slideScreen.style.left = '0'
  }

  function showSpacingVariablesScreen(spacingVariables) {
    // Hide the validation footer when viewing tokens
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'none'
    }

    const slideScreen = document.getElementById('spacing-variables-view-screen')
    const content = document.getElementById('spacing-variables-content')

    if (Object.keys(spacingVariables).length === 0) {
      content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">No spacing variables found in this library.</div>'
      slideScreen.style.left = '0'
      return
    }

    // Generate HTML for spacing variables
    const spacingItems = Object.entries(spacingVariables).map(([name, data]) => {
      // Extract the pixel value from the variable data
      let pixelValue = 'Unknown'
      if (data.values && typeof data.values === 'object') {
        const firstModeValues = Object.values(data.values)[0]
        if (typeof firstModeValues === 'number') {
          pixelValue = `${firstModeValues}px`
        }
      }

      return `<div class="text-style-item">
        <div class="text-style-info">
          <h4>${name}</h4>
          <p>Spacing token for consistent layout</p>
        </div>
        <div class="text-style-size">${pixelValue}</div>
      </div>`
    }).join('')

    const html = `<div class="text-style-group">
      <div class="text-style-group-title">Spacing Variables</div>
      ${spacingItems}
    </div>`

    content.innerHTML = html

    // Show slide-in screen
    slideScreen.style.left = '0'
  }

  function showColorsScreen(colors) {
    // Hide the validation footer when viewing tokens
    const validationFooter = document.getElementById('home-sticky-footer')
    if (validationFooter) {
      validationFooter.style.display = 'none'
    }

    const slideScreen = document.getElementById('colors-view-screen')
    const content = document.getElementById('colors-content')

    if (Object.keys(colors).length === 0) {
      content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">No color tokens found in this library.</div>'
      slideScreen.style.left = '0'
      return
    }

    // Group colors by category, then by color name with variants
    const colorsByCategory = {}

    Object.entries(colors).forEach(([name, data]) => {
      // Parse name: "Feedback/Error/50" -> category: "Feedback", color: "Error", variant: "50"
      const parts = name.split('/')
      const category = parts[0] || 'Other'
      const colorName = parts[1] || name
      const variant = parts[2] || 'Default'

      if (!colorsByCategory[category]) {
        colorsByCategory[category] = {}
      }

      if (!colorsByCategory[category][colorName]) {
        colorsByCategory[category][colorName] = []
      }

      colorsByCategory[category][colorName].push({ variant, data, fullName: name })
    })

    // Sort categories with Brand first, then alphabetical
    const sortedCategories = Object.entries(colorsByCategory).sort(([a], [b]) => {
      if (a === 'Brand') return -1
      if (b === 'Brand') return 1
      return a.localeCompare(b)
    })

    // Generate HTML for each category
    const categoryGroups = sortedCategories.map(([category, colorGroups]) => {
      // Sort color groups within category
      const sortedColorGroups = Object.entries(colorGroups).sort(([a], [b]) => a.localeCompare(b))

      const colorGroupItems = sortedColorGroups.map(([colorName, variants]) => {
        // Sort variants numerically if they're numbers, otherwise alphabetically
        const sortedVariants = variants.sort((a, b) => {
          const aNum = parseInt(a.variant)
          const bNum = parseInt(b.variant)
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return aNum - bNum
          }
          return a.variant.localeCompare(b.variant)
        })

        // Create variant items
        const variantItems = sortedVariants.map(({ variant, data, fullName }) => {
          // Extract the color value from the variable data
          let colorValue = '#000000'
          let displayValue = 'Unknown'

          if (data.values && typeof data.values === 'object') {
            const firstModeValues = Object.values(data.values)[0]
            if (typeof firstModeValues === 'object' && firstModeValues.r !== undefined) {
              // RGB color object
              const r = Math.round(firstModeValues.r * 255)
              const g = Math.round(firstModeValues.g * 255)
              const b = Math.round(firstModeValues.b * 255)
              colorValue = `rgb(${r}, ${g}, ${b})`
              displayValue = colorValue
            } else if (typeof firstModeValues === 'string') {
              // Hex color string
              colorValue = firstModeValues
              displayValue = firstModeValues
            }
          }

          return `<div class="text-style-item" style="margin-left: 20px; border-left: 2px solid ${colorValue}; padding-left: 16px; background: rgba(0,0,0,0.02);">
            <div class="text-style-info">
              <h4 style="font-size: 14px; font-weight: 600; color: #374151;">${variant}</h4>
              <p style="font-size: 12px; color: #6b7280;">${displayValue}</p>
            </div>
            <div class="text-style-size" style="display: flex; align-items: center; gap: 8px;">
              <div style="width: 24px; height: 24px; border-radius: 6px; background: ${colorValue}; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);"></div>
            </div>
          </div>`
        }).join('')

        return `<div style="margin-bottom: 24px; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <div style="font-size: 16px; font-weight: 600; color: #374151; margin-bottom: 0; padding: 12px 16px; background: #f9fafb; border-bottom: 1px solid #e5e7eb;">
            ${colorName} <span style="font-size: 14px; font-weight: 400; color: #6b7280;">(${variants.length} variants)</span>
          </div>
          <div style="padding: 8px 0;">
            ${variantItems}
          </div>
        </div>`
      }).join('')

      const totalTokens = Object.values(colorGroups).reduce((sum, variants) => sum + variants.length, 0)

      return `<div class="text-style-group" style="margin-bottom: 32px;">
        <div class="text-style-group-title">${category} <span style="font-size: 14px; font-weight: 400; color: #6b7280;">(${totalTokens})</span></div>
        ${colorGroupItems}
      </div>`
    }).join('')

    const html = `<div style="padding-bottom: 20px;">
      ${categoryGroups}
    </div>`

    content.innerHTML = html

    // Show slide-in screen
    slideScreen.style.left = '0'
  }

  function showCornerRadiusScreen(cornerRadiusVariables) {
    const slideScreen = document.getElementById('corner-radius-view-screen')
    const content = document.getElementById('corner-radius-content')

    if (Object.keys(cornerRadiusVariables).length === 0) {
      content.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">No corner radius tokens found in this library.</div>'
      slideScreen.style.left = '0'
      return
    }

    // Generate HTML for corner radius variables
    const radiusItems = Object.entries(cornerRadiusVariables).map(([name, data]) => {
      // Extract the pixel value from the variable data
      let pixelValue = 'Unknown'
      if (data.values && typeof data.values === 'object') {
        const firstModeValues = Object.values(data.values)[0]
        if (typeof firstModeValues === 'number') {
          pixelValue = `${firstModeValues}px`
        }
      }

      return `<div class="text-style-item">
        <div class="text-style-info">
          <h4>${name}</h4>
          <p>Corner radius token for consistent rounded corners</p>
        </div>
        <div class="text-style-size">${pixelValue}</div>
      </div>`
    }).join('')

    const html = `<div class="text-style-group">
      <div class="text-style-group-title">Corner Radius Tokens</div>
      ${radiusItems}
    </div>`

    content.innerHTML = html

    // Show slide-in screen
    slideScreen.style.left = '0'
  }

  function generateDynamicTabs(activeResults, options) {
    const categoryTabsContainer = document.getElementById('category-tabs')
    if (!categoryTabsContainer) return

    // Clear existing tabs
    categoryTabsContainer.innerHTML = ''

    // Always show "All" tab
    const allCount = activeResults.length
    const allTab = document.createElement('button')
    allTab.id = 'all-tab'
    allTab.className = 'category-tab-button active'
    allTab.setAttribute('data-tab', 'all')
    allTab.textContent = `All (${allCount})`
    categoryTabsContainer.appendChild(allTab)

    // Define tab configurations with their display names and result types
    const tabConfigs = [
      { key: 'textStyles', label: 'Text Styles', type: 'text-style' },
      { key: 'spacing', label: 'Spacing', type: 'spacing' },
      { key: 'colors', label: 'Colors', type: 'color' },
      { key: 'cornerRadius', label: 'Corner Radius', type: 'corner-radius' },
      { key: 'typography', label: 'Typography', type: 'typography' },
      { key: 'shadows', label: 'Shadows', type: 'shadow' },
      { key: 'borders', label: 'Borders', type: 'border' },
      { key: 'opacity', label: 'Opacity', type: 'opacity' },
      { key: 'sizing', label: 'Sizing', type: 'sizing' }
    ]

    // Create tabs only for selected validation options that have results
    tabConfigs.forEach(config => {
      if (options && options[config.key]) {
        const issueCount = activeResults.filter(r => r.type === config.type).length
        if (issueCount > 0) {
          const tab = document.createElement('button')
          tab.id = `${config.key.toLowerCase()}-tab`
          tab.className = 'category-tab-button'
          tab.setAttribute('data-tab', config.type)
          tab.textContent = `${config.label} (${issueCount})`
          categoryTabsContainer.appendChild(tab)
        }
      }
    })

    // Update issues count
    const issuesCountElement = document.getElementById('issues-count')
    if (issuesCountElement) {
      issuesCountElement.textContent = `Found ${allCount} issues`
    }

    console.log('Generated dynamic tabs based on validation options and results')
  }

  function showValidationResults(results, library, targetName, targetType, options) {
    console.log('showValidationResults called with:', results)
    console.log('Library data:', library)
    console.log('Target:', targetName, 'Type:', targetType)
    console.log('Validation options:', options)

    // Initialize issue state tracking
    if (!window.issueStates) {
      window.issueStates = new Map() // nodeId -> 'active' | 'resolved' | 'ignored'
    }

    // Reset updated items when new validation results are shown
    window.updatedItems = new Set()
    console.log('Reset updated items for new validation results')

    // Store results and library globally for filtering
    window.validationResults = results
    window.validationLibrary = library

    // Initialize filters
    window.currentCategoryFilter = 'all'
    window.currentStatusFilter = 'active'

    // Generate dynamic tabs based on selected validation options and results
    generateDynamicTabs(results, options)

    // Apply initial filters and show results
    applyFilters()

    // Show the results screen
    showScreen('validation-results')
  }

  function applyFilters() {
    let allResults = window.validationResults || []
    const categoryFilter = window.currentCategoryFilter || 'all'
    const statusFilter = window.currentStatusFilter || 'active'
    const issueStates = window.issueStates || new Map()

    console.log('Applying filters:', { categoryFilter, statusFilter })

    // Filter by category first
    let filteredResults = allResults
    if (categoryFilter !== 'all') {
      filteredResults = filteredResults.filter(r => r.type === categoryFilter)
    }

    // Then filter by status
    filteredResults = filteredResults.filter(result => {
      const nodeId = result.node?.id
      if (!nodeId) return statusFilter === 'active' // No nodeId means active by default

      const issueState = issueStates.get(nodeId) || 'active'
      return issueState === statusFilter
    })

    // For resolved items, update them to show current state instead of original validation data
    if (statusFilter === 'resolved') {
      filteredResults = filteredResults.map(result => {
        if (result.type === 'corner-radius') {
          return updateResolvedCornerRadiusResult(result)
        } else if (result.type === 'spacing') {
          return updateResolvedSpacingResult(result)
        } else if (result.type === 'text-style') {
          return updateResolvedTextStyleResult(result)
        } else if (result.type === 'color') {
          return updateResolvedColorResult(result)
        }
        return result
      })
    }

    console.log(`Filtered results: ${allResults.length} -> ${filteredResults.length}`)

    // Update status tab counts
    updateStatusTabCounts()

    // Display filtered results
    displayValidationResults(filteredResults)
  }

  function updateResolvedTextStyleResult(result) {
    // For resolved text style items, show them with stored resolved state
    const updatedResult = { ...result }
    const nodeId = result.node?.id

    // Update the issue text to reflect resolved state
    updatedResult.issue = '✓ Using design system text style'

    // Get resolved state from stored data
    const resolvedTextStates = window.resolvedTextStates || new Map()
    const resolvedTextStyle = resolvedTextStates.get(nodeId)

    if (resolvedTextStyle) {
      updatedResult.resolvedStyleName = resolvedTextStyle.styleName
      updatedResult.resolvedDisplayText = resolvedTextStyle.displayText
    }

    return updatedResult
  }

  function updateResolvedColorResult(result) {
    // For resolved color items, show them with stored resolved state
    const updatedResult = { ...result }
    const nodeId = result.node?.id

    // Update the issue text to reflect resolved state
    updatedResult.issue = '✓ Using design token'

    // Get resolved state from stored data
    const resolvedColorStates = window.resolvedColorStates || new Map()
    const resolvedColorToken = resolvedColorStates.get(nodeId)

    if (resolvedColorToken) {
      updatedResult.resolvedTokenName = resolvedColorToken.tokenName
      updatedResult.resolvedDisplayText = resolvedColorToken.displayText
    }

    return updatedResult
  }

  function updateResolvedCornerRadiusResult(result) {
    // For resolved corner radius items, show them with stored resolved state
    const updatedResult = { ...result }
    const nodeId = result.node?.id

    // Update the issue text to reflect resolved state
    updatedResult.issue = '✓ Using design tokens'

    // Get resolved state from stored data
    if (updatedResult.cornerValues && nodeId) {
      const resolvedStates = window.resolvedCornerStates || new Map()
      const nodeResolvedState = resolvedStates.get(nodeId)

      if (nodeResolvedState) {
        // Use stored resolved state
        updatedResult.cornerValues = nodeResolvedState
      } else {
        // Fallback: show all corners as resolved with generic tokens
        const updatedCornerValues = {}
        Object.keys(updatedResult.cornerValues).forEach(corner => {
          const originalCorner = updatedResult.cornerValues[corner]
          if (originalCorner && typeof originalCorner === 'object') {
            // For resolved items, show appropriate resolved state
            if (originalCorner.value === 0) {
              updatedCornerValues[corner] = {
                value: '0',
                hasToken: false // 0 is hardcoded but not an issue
              }
            } else {
              updatedCornerValues[corner] = {
                value: getResolvedTokenName(originalCorner.value),
                hasToken: true
              }
            }
          } else {
            updatedCornerValues[corner] = {
              value: getResolvedTokenName(originalCorner),
              hasToken: true
            }
          }
        })
        updatedResult.cornerValues = updatedCornerValues
      }
    }

    return updatedResult
  }

  function truncateText(text, maxLength = 20, preferWordBoundary = true) {
    if (!text || text.length <= maxLength) return text

    // If we prefer word boundaries and the text is long enough
    if (preferWordBoundary && maxLength > 10) {
      // Look for the last space within the limit
      const truncated = text.substring(0, maxLength)
      const lastSpaceIndex = truncated.lastIndexOf(' ')

      // If we found a space and it's not too close to the beginning
      if (lastSpaceIndex > maxLength * 0.6) {
        return text.substring(0, lastSpaceIndex) + '...'
      }
    }

    // Fallback to character-based truncation
    return text.substring(0, maxLength) + '...'
  }

  // Enhanced truncation for collapsed view with responsive length
  function truncateForCollapsedView(text, containerWidth = 200) {
    if (!text) return text

    // For collapsed view, be more aggressive with truncation
    // Use smaller character estimate and lower max limit
    const baseLength = Math.floor(containerWidth / 10) // More conservative estimate
    const maxLength = Math.max(12, Math.min(baseLength, 25)) // Between 12-25 chars for collapsed view

    console.log(`Truncation calculation: containerWidth=${containerWidth}, baseLength=${baseLength}, maxLength=${maxLength}`)
    return truncateText(text, maxLength, true)
  }

  // Create truncated text with enhanced tooltip support
  function createTruncatedTextElement(text, containerWidth = 200, className = 'collapsed-issue-text') {
    if (!text) return ''

    // FORCE aggressive truncation for collapsed view - hard limit of 20 characters
    let finalText = text
    if (text.length > 20) {
      // Look for word boundary within first 17 characters
      const truncated = text.substring(0, 17)
      const lastSpace = truncated.lastIndexOf(' ')
      if (lastSpace > 10) {
        finalText = text.substring(0, lastSpace) + '...'
      } else {
        finalText = text.substring(0, 17) + '...'
      }
    }

    const isTruncated = finalText !== text
    const classNames = isTruncated ? `${className} truncated` : className
    const dataAttr = isTruncated ? `data-full-text="${text.replace(/"/g, '&quot;')}"` : ''

    console.log(`FORCE TRUNCATION: "${text}" -> "${finalText}" (truncated: ${isTruncated})`)

    return {
      html: finalText,
      className: classNames,
      dataAttr: dataAttr,
      isTruncated: isTruncated
    }
  }

  // Get available width for text in collapsed view
  function getAvailableTextWidth() {
    const collapsedContent = document.getElementById('collapsed-view-content')
    if (!collapsedContent) return 200 // Default to smaller width

    const contentWidth = collapsedContent.offsetWidth
    // Account for padding, margins, and other elements (badge, buttons, etc.)
    // Be more conservative with reserved space for collapsed view
    const reservedWidth = Math.max(400, contentWidth * 0.6) // Reserve 60% or at least 400px
    const availableWidth = Math.max(150, contentWidth - reservedWidth)

    console.log(`Collapsed view width calculation: container=${contentWidth}, reserved=${reservedWidth}, available=${availableWidth}`)
    return availableWidth
  }

  // Refresh truncation when window resizes
  function refreshCollapsedViewTruncation() {
    if (window.isValidationMinimized && window.currentSelectedNodeId) {
      updateCollapsedViewForSelectedNode()
    }
  }

  // Truncate frame names for collapsed view
  function truncateFrameName(frameName, maxLength = 60) {
    if (!frameName || frameName.length <= maxLength) return frameName
    return frameName.substring(0, maxLength) + '...'
  }

  // Debounce utility function
  function debounce(func, wait) {
    let timeout
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout)
        func(...args)
      }
      clearTimeout(timeout)
      timeout = setTimeout(later, wait)
    }
  }

  // Add resize listener for responsive truncation
  window.addEventListener('resize', debounce(refreshCollapsedViewTruncation, 250))

  // Test truncation on page load
  window.addEventListener('DOMContentLoaded', () => {
    console.log('Testing truncation functions:')
    console.log('Short text:', truncateText('Short text', 20))
    console.log('Long text:', truncateText('this si a asdasd asdasd a asda asdasd asda this si a asdasd asdasd a asda asdasd asda this si a asdasd asdasd a asda asdasd asda', 25))
    console.log('Collapsed view test:', truncateForCollapsedView('this si a asdasd asdasd a asda asdasd asda this si a asdasd asdasd a asda asdasd asda', 200))
  })

  function getResolvedTokenName(originalValue) {
    // Map common values to likely token names for resolved display
    if (typeof originalValue === 'number') {
      if (originalValue === 0) return '0'
      if (originalValue <= 4) return '4'
      if (originalValue <= 8) return '8'
      if (originalValue <= 12) return '12'
      if (originalValue <= 16) return '16'
      if (originalValue <= 24) return '24'
      return `${originalValue}`
    }
    return 'token'
  }

  function updateResolvedSpacingResult(result) {
    // For resolved spacing items, show them with stored resolved state
    const updatedResult = { ...result }
    const nodeId = result.node?.id

    // Update the issue text to reflect resolved state
    updatedResult.issue = '✓ Using design tokens'

    // Get resolved state from stored data
    if (nodeId) {
      const resolvedStates = window.resolvedSpacingStates || new Map()
      const nodeResolvedState = resolvedStates.get(nodeId)

      if (nodeResolvedState) {
        // Use stored resolved state
        updatedResult.value = nodeResolvedState.value
      } else {
        // Fallback: show resolved token name based on original value
        updatedResult.value = getResolvedTokenName(result.value)
      }
    }

    return updatedResult
  }

  function updateStatusTabCounts() {
    const allResults = window.validationResults || []
    const issueStates = window.issueStates || new Map()

    let activeCounts = { all: 0, byType: {} }
    let resolvedCounts = { all: 0, byType: {} }
    let ignoredCounts = { all: 0, byType: {} }

    allResults.forEach(result => {
      const nodeId = result.node?.id
      const issueState = nodeId ? (issueStates.get(nodeId) || 'active') : 'active'
      const resultType = result.type

      if (issueState === 'active') {
        activeCounts.all++
        activeCounts.byType[resultType] = (activeCounts.byType[resultType] || 0) + 1
      } else if (issueState === 'resolved') {
        resolvedCounts.all++
        resolvedCounts.byType[resultType] = (resolvedCounts.byType[resultType] || 0) + 1
      } else if (issueState === 'ignored') {
        ignoredCounts.all++
        ignoredCounts.byType[resultType] = (ignoredCounts.byType[resultType] || 0) + 1
      }
    })

    // Update status tab labels
    const activeTab = document.getElementById('active-tab')
    const resolvedTab = document.getElementById('resolved-tab')
    const ignoredTab = document.getElementById('ignored-tab')

    if (activeTab) activeTab.textContent = `Active (${activeCounts.all})`
    if (resolvedTab) resolvedTab.textContent = `Resolved (${resolvedCounts.all})`
    if (ignoredTab) ignoredTab.textContent = `Ignored (${ignoredCounts.all})`

    // Update issues count header
    const currentStatusFilter = window.currentStatusFilter || 'active'
    let currentCount = 0
    if (currentStatusFilter === 'active') currentCount = activeCounts.all
    else if (currentStatusFilter === 'resolved') currentCount = resolvedCounts.all
    else if (currentStatusFilter === 'ignored') currentCount = ignoredCounts.all

    const issuesCountElement = document.getElementById('issues-count')
    if (issuesCountElement) {
      const statusLabel = currentStatusFilter === 'active' ? 'issues' : `${currentStatusFilter} issues`
      issuesCountElement.textContent = `Found ${currentCount} ${statusLabel}`
    }
  }

  function resolveIssue(nodeId) {
    console.log('Resolving issue for node:', nodeId)
    const issueStates = window.issueStates || new Map()
    issueStates.set(nodeId, 'resolved')
    window.issueStates = issueStates

    // Refresh the current view
    applyFilters()

    // Show success notification
    showNotification('Issue resolved successfully', 'success')
  }

  function ignoreIssue(nodeId) {
    console.log('Ignoring issue for node:', nodeId)
    const issueStates = window.issueStates || new Map()
    issueStates.set(nodeId, 'ignored')
    window.issueStates = issueStates

    // Update tab counts immediately
    updateStatusTabCounts()
    updateCategoryTabCounts()

    // Refresh the current view
    applyFilters()

    // Show success notification
    showNotification('Issue ignored', 'info')
  }

  function showNotification(message, type = 'info') {
    // Simple notification - you can enhance this later
    console.log(`${type.toUpperCase()}: ${message}`)
    // Could add a toast notification here in the future
  }

  function getTextStyleOptions() {
    const library = window.validationLibrary
    if (!library || !library.items) return ''

    let options = ''
    Object.keys(library.items).forEach(styleName => {
      options += `<option value="${styleName}">${styleName}</option>`
    })
    return options
  }

  function getTextStyleOptionsArray() {
    const library = window.validationLibrary
    console.log('getTextStyleOptionsArray called, library:', library)

    if (!library || !library.items) {
      console.log('No library or items found')
      return []
    }

    const options = Object.keys(library.items).map(styleName => ({
      value: styleName,
      text: styleName
    }))

    console.log('Generated options:', options)
    return options
  }

  // Create custom dropdown for validation results
  function createValidationDropdown(nodeId, isSpacing = false) {
    // Sanitize nodeId for use in CSS selectors (replace invalid characters)
    const sanitizedNodeId = nodeId.replace(/[^a-zA-Z0-9-_]/g, '-')
    const dropdownId = `validation-dropdown-${sanitizedNodeId}`
    const textId = `validation-text-${sanitizedNodeId}`
    const optionsId = `validation-options-${sanitizedNodeId}`

    return `
      <div class="custom-dropdown validation-dropdown" id="${dropdownId}" data-node-id="${nodeId}" style="min-width: 200px;">
        <button class="btn btn-primary validation-dropdown-selected" style="border: 2px solid red; background: white !important; color: var(--color-gray-700) !important; display: flex; align-items: center; justify-content: space-between; min-width: 200px; padding-right: 24px !important;">
          <span id="${textId}">Select a style...</span>
          <svg class="dropdown-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px; transition: transform 0.2s ease; flex-shrink: 0; color: var(--color-gray-500);">
            <path d="m6 9 6 6 6-6"/>
          </svg>
        </button>
        <div class="dropdown-options" id="${optionsId}" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid var(--color-gray-300); border-top: none; border-radius: 0 0 var(--radius-md) var(--radius-md); box-shadow: var(--shadow-lg); z-index: 1000; max-height: 200px; overflow-y: auto; display: none;">
          <!-- Options will be populated by JavaScript -->
        </div>
      </div>
    `
  }

  function getSpacingTokensArray() {
    const library = window.validationLibrary
    console.log('getSpacingTokensArray called, library:', library)

    if (!library || !library.variables) {
      console.log('No library or variables found')
      return []
    }

    let spacingVariables = {}

    // Check if using new structure (organized by collection)
    if (library.variables.spacing) {
      spacingVariables = library.variables.spacing
    } else {
      // Handle old structure (flat with collection names in keys)
      for (const key in library.variables) {
        if (key.toLowerCase().startsWith('spacing/')) {
          const variableName = key.replace(/^spacing\//i, '')
          spacingVariables[variableName] = library.variables[key]
        }
      }
    }

    const options = Object.entries(spacingVariables).map(([name, data]) => {
      // Extract the pixel value from the variable data
      let pixelValue = 'Unknown'
      if (data && data.values && typeof data.values === 'object') {
        const firstModeValues = Object.values(data.values)[0]
        if (typeof firstModeValues === 'number') {
          pixelValue = `${firstModeValues}px`
        }
      }

      return {
        value: name,
        text: `${name} (${pixelValue})`,
        pixelValue: pixelValue
      }
    })

    console.log('Generated spacing options:', options)
    return options
  }

  function getCornerRadiusTokensArray() {
    const library = window.validationLibrary
    console.log('getCornerRadiusTokensArray called, library:', library)

    if (!library || !library.variables) {
      console.log('No library or variables found')
      return []
    }

    let cornerRadiusVariables = {}

    // Check if using new structure (organized by collection)
    if (library.variables['corner-radius'] || library.variables.cornerRadius) {
      cornerRadiusVariables = library.variables['corner-radius'] || library.variables.cornerRadius
    } else {
      // Handle old structure and search through all collections for corner radius-related variables
      for (const [collectionKey, variables] of Object.entries(library.variables)) {
        const collectionName = collectionKey.toLowerCase()

        // Check if this collection contains corner radius
        if (collectionName.includes('radius') || collectionName.includes('corner') ||
          collectionName.includes('border-radius') || collectionName.includes('rounded')) {
          // Add all variables from this collection
          Object.assign(cornerRadiusVariables, variables)
        } else {
          // Check individual variable names for corner radius-related terms
          for (const [varName, varData] of Object.entries(variables)) {
            const name = varName.toLowerCase()
            if (name.includes('radius') || name.includes('corner') || name.includes('rounded')) {
              cornerRadiusVariables[varName] = varData
            }
          }
        }
      }
    }

    const options = Object.entries(cornerRadiusVariables).map(([name, data]) => {
      // Extract the pixel value from the variable data
      let pixelValue = 'Unknown'
      if (data && data.values && typeof data.values === 'object') {
        const firstModeValues = Object.values(data.values)[0]
        if (typeof firstModeValues === 'number') {
          pixelValue = `${firstModeValues}px`
        }
      }

      return {
        value: name,
        text: `${name} (${pixelValue})`,
        pixelValue: pixelValue
      }
    })

    console.log('Generated corner radius options:', options)
    return options
  }

  function getColorTokensArray() {
    const library = window.validationLibrary
    console.log('getColorTokensArray called, library:', library)

    if (!library || !library.variables) {
      console.log('No library or variables found')
      return []
    }

    let colorVariables = {}

    // Check if using new structure (organized by collection)
    if (library.variables.colors || library.variables.color) {
      colorVariables = library.variables.colors || library.variables.color
    } else {
      // Handle old structure and search through all collections for color-related variables
      for (const [collectionKey, variables] of Object.entries(library.variables)) {
        const collectionName = collectionKey.toLowerCase()

        // Check if this collection contains colors
        if (collectionName.includes('color') || collectionName.includes('colour') ||
          collectionName === 'colors' || collectionName === 'colours') {
          // Add all variables from this collection
          Object.assign(colorVariables, variables)
        } else {
          // Check individual variable names for color-related terms
          for (const [varName, varData] of Object.entries(variables)) {
            const name = varName.toLowerCase()
            if (name.includes('color') || name.includes('colour')) {
              colorVariables[varName] = varData
            }
          }
        }
      }
    }

    // Group colors by category and color name, similar to token view
    const colorsByCategory = {}

    Object.entries(colorVariables).forEach(([name, data]) => {
      // Parse name: "Brand/Primary/50" -> category: "Brand", color: "Primary", variant: "50"
      const parts = name.split('/')
      const category = parts[0] || 'Other'
      const colorName = parts[1] || name
      const variant = parts[2] || 'Default'

      if (!colorsByCategory[category]) {
        colorsByCategory[category] = {}
      }

      if (!colorsByCategory[category][colorName]) {
        colorsByCategory[category][colorName] = []
      }

      // Extract color value
      let colorValue = '#000000'
      if (data && data.values && typeof data.values === 'object') {
        const firstModeValues = Object.values(data.values)[0]
        if (typeof firstModeValues === 'object' && firstModeValues !== null) {
          const colorObj = firstModeValues
          if (typeof colorObj.r === 'number' && typeof colorObj.g === 'number' && typeof colorObj.b === 'number') {
            const r = Math.round(colorObj.r * 255)
            const g = Math.round(colorObj.g * 255)
            const b = Math.round(colorObj.b * 255)
            const a = colorObj.a !== undefined ? colorObj.a : 1
            if (a < 1) {
              colorValue = `rgba(${r}, ${g}, ${b}, ${a})`
            } else {
              colorValue = `rgb(${r}, ${g}, ${b})`
            }
          }
        } else if (typeof firstModeValues === 'string') {
          colorValue = firstModeValues
        }
      }

      colorsByCategory[category][colorName].push({
        variant,
        colorValue,
        fullName: name,
        data
      })
    })

    // Convert grouped structure to flat options array for dropdown
    const options = []

    // Sort categories with Brand first
    const sortedCategories = Object.entries(colorsByCategory).sort(([a], [b]) => {
      if (a === 'Brand') return -1
      if (b === 'Brand') return 1
      return a.localeCompare(b)
    })

    sortedCategories.forEach(([category, colorGroups]) => {
      // Sort color groups within category
      const sortedColorGroups = Object.entries(colorGroups).sort(([a], [b]) => a.localeCompare(b))

      sortedColorGroups.forEach(([colorName, variants]) => {
        // Add color group header (e.g., "Brand/Primary")
        options.push({
          value: '',
          text: `${category}/${colorName}`,
          isColorGroupHeader: true,
          category: category,
          colorName: colorName
        })

        // Sort variants numerically
        const sortedVariants = variants.sort((a, b) => {
          const aNum = parseInt(a.variant)
          const bNum = parseInt(b.variant)
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return aNum - bNum
          }
          return a.variant.localeCompare(b.variant)
        })

        // Add each variant as an option (just the variant number)
        sortedVariants.forEach(({ variant, colorValue, fullName }) => {
          options.push({
            value: fullName,
            text: variant,
            colorValue: colorValue,
            category: category,
            colorName: colorName,
            variant: variant,
            isVariant: true
          })
        })
      })
    })

    console.log('Generated grouped color options:', options)
    return options
  }



  function setupValidationEventHandlers() {
    console.log('Setting up simple dropdown handlers')

    // Initialize corner radius selectedToken properties (but don't enable buttons)
    // Buttons should only be enabled when users actively select tokens
    document.querySelectorAll('.corner-radius-dropdown').forEach(dropdown => {
      const tokenBadge = dropdown.querySelector('.corner-token-badge.existing-token')
      if (tokenBadge) {
        // Mark existing tokens but don't count them for button enabling
        dropdown.hasExistingToken = true
        dropdown.existingTokenValue = tokenBadge.textContent
      }
    })

    // Setup simple dropdown functionality
    document.querySelectorAll('.simple-dropdown').forEach(dropdown => {
      // Skip if already has event handlers
      if (dropdown.hasAttribute('data-handlers-attached')) {
        return
      }

      // Mark as having handlers attached
      dropdown.setAttribute('data-handlers-attached', 'true')
      const trigger = dropdown.querySelector('.dropdown-trigger')
      const optionsContainer = dropdown.querySelector('.dropdown-options')
      const text = dropdown.querySelector('.dropdown-text')
      const arrow = dropdown.querySelector('.dropdown-arrow')
      const nodeId = dropdown.getAttribute('data-node-id')
      const resultType = dropdown.getAttribute('data-result-type')

      // Determine dropdown type and get appropriate options
      const isSpacing = resultType === 'spacing'
      const isCornerRadius = resultType === 'corner-radius'
      const isColor = resultType === 'color'

      // Check if we're in resolved tab and if this node has resolved states
      const currentStatusFilter = window.currentStatusFilter || 'active'
      const isResolved = currentStatusFilter === 'resolved'
      const resolvedTextStates = window.resolvedTextStates || new Map()
      const resolvedTextStyle = resolvedTextStates.get(nodeId)
      const resolvedColorStates = window.resolvedColorStates || new Map()
      const resolvedColorToken = resolvedColorStates.get(nodeId)

      // Get appropriate options based on type
      let optionsList = []
      let defaultText = 'Select a style...'

      if (isSpacing) {
        optionsList = getSpacingTokensArray()
        defaultText = 'Select token...'
      } else if (isCornerRadius) {
        optionsList = getCornerRadiusTokensArray()
        defaultText = 'Select radius...'
      } else if (isColor) {
        optionsList = getColorTokensArray()
        defaultText = 'Select color...'

        // If resolved and has a resolved color token, show it
        if (isResolved && resolvedColorToken) {
          defaultText = resolvedColorToken.displayText || resolvedColorToken.tokenName
        }
      } else {
        optionsList = getTextStyleOptionsArray()
        defaultText = 'Select a style...'

        // If resolved and has a resolved text style, show it
        if (isResolved && resolvedTextStyle) {
          defaultText = resolvedTextStyle.displayText || resolvedTextStyle.styleName
        }
      }

      optionsContainer.innerHTML = ''

      // Set initial text
      text.textContent = defaultText

      // If resolved and has resolved state, disable the dropdown
      if (isResolved && ((resolvedTextStyle && !isSpacing && !isCornerRadius && !isColor) || (resolvedColorToken && isColor))) {
        trigger.disabled = true
        trigger.style.cssText += '; cursor: not-allowed; opacity: 0.6; background: #f9fafb !important;'
        // Don't populate options for disabled resolved dropdowns
        return
      }

      // Add default option (only for non-resolved or non-text-style dropdowns)
      const defaultOption = document.createElement('div')
      defaultOption.style.cssText = 'padding: 8px 12px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease;'
      defaultOption.textContent = defaultText
      defaultOption.addEventListener('click', () => selectOption('', defaultText))
      defaultOption.addEventListener('mouseenter', () => defaultOption.style.background = 'var(--color-gray-50)')
      defaultOption.addEventListener('mouseleave', () => defaultOption.style.background = 'white')
      optionsContainer.appendChild(defaultOption)

      // Add options (text styles, spacing tokens, or colors)
      optionsList.forEach(option => {
        const optionElement = document.createElement('div')

        // Handle color group headers (e.g., "Brand/Primary")
        if (option.isColorGroupHeader) {
          optionElement.style.cssText = 'padding: 12px 12px 6px 12px; font-weight: 600; font-size: 12px; color: var(--color-gray-800); background: white; cursor: default; border-bottom: none; margin-top: 8px; border-top: 1px solid #f1f5f9;'
          optionElement.textContent = option.text
          // No click handler for headers
        } else if (isColor && option.isVariant && option.colorValue) {
          // Color variant with swatch (just the number)
          optionElement.style.cssText = 'padding: 6px 12px 6px 24px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease; display: flex; align-items: center; gap: 8px;'

          // Create color swatch (50% smaller)
          const swatch = document.createElement('div')
          swatch.style.cssText = `width: 12px; height: 12px; border-radius: 3px; background: ${option.colorValue}; border: 1px solid #e5e7eb; flex-shrink: 0;`

          // Create text span (smaller but readable)
          const textSpan = document.createElement('span')
          textSpan.style.cssText = 'font-size: 12px; font-weight: 500; color: var(--color-gray-800);'
          textSpan.textContent = option.text

          optionElement.appendChild(swatch)
          optionElement.appendChild(textSpan)

          optionElement.addEventListener('click', () => selectOption(option.value, option.text))
          optionElement.addEventListener('mouseenter', () => optionElement.style.background = 'var(--color-gray-50)')
          optionElement.addEventListener('mouseleave', () => optionElement.style.background = 'white')
        } else {
          // Regular option (text styles, spacing, etc.)
          optionElement.style.cssText = 'padding: 8px 12px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease;'
          optionElement.textContent = option.text
          optionElement.addEventListener('click', () => selectOption(option.value, option.text))
          optionElement.addEventListener('mouseenter', () => optionElement.style.background = 'var(--color-gray-50)')
          optionElement.addEventListener('mouseleave', () => optionElement.style.background = 'white')
        }

        optionsContainer.appendChild(optionElement)
      })

      // Toggle dropdown
      trigger.addEventListener('click', (e) => {
        e.stopPropagation()

        // Don't open if disabled
        if (trigger.disabled) {
          return
        }

        const isOpen = optionsContainer.style.display === 'block'

        // Close all other dropdowns
        document.querySelectorAll('.simple-dropdown .dropdown-options').forEach(opt => {
          opt.style.display = 'none'
        })
        document.querySelectorAll('.simple-dropdown .dropdown-arrow').forEach(arr => {
          arr.style.transform = 'rotate(0deg)'
        })

        // Toggle this dropdown
        if (!isOpen) {
          optionsContainer.style.display = 'block'
          arrow.style.transform = 'rotate(180deg)'
        } else {
          optionsContainer.style.display = 'none'
          arrow.style.transform = 'rotate(0deg)'
        }
      })

      // Close dropdown when clicking outside
      document.addEventListener('click', () => {
        optionsContainer.style.display = 'none'
        arrow.style.transform = 'rotate(0deg)'
      })

      // Select option function
      function selectOption(value, displayText) {
        text.textContent = displayText
        optionsContainer.style.display = 'none'
        arrow.style.transform = 'rotate(0deg)'

        // Update button state
        const updateBtn = document.querySelector(`.update-btn[data-node-id="${nodeId}"]`)
        if (updateBtn) {
          if (value && value !== '') {
            updateBtn.disabled = false
          } else {
            updateBtn.disabled = true
          }
        }

        // Store selected value for later use
        dropdown.selectedValue = value
      }
    })

    // Setup view button handlers
    document.querySelectorAll('.view-node-btn').forEach(btn => {
      // Skip if already has event handlers
      if (btn.hasAttribute('data-handlers-attached')) {
        return
      }

      // Mark as having handlers attached
      btn.setAttribute('data-handlers-attached', 'true')

      btn.addEventListener('click', function () {
        const nodeId = this.getAttribute('data-node-id')
        if (nodeId) {
          console.log('View button clicked for node:', nodeId)

          // First, select the node in Figma
          parent.postMessage({
            pluginMessage: {
              type: 'select-node',
              nodeId: nodeId
            }
          }, '*')

          // Set the current selected node for collapsed view
          window.currentSelectedNodeId = nodeId

          // Trigger collapsed mode if not already minimized
          if (!window.isValidationMinimized) {
            console.log('Switching to collapsed mode via minimize button')
            const minimizeBtn = document.getElementById('minimize-btn')
            if (minimizeBtn) {
              // Trigger the minimize button click to enter collapsed mode
              minimizeBtn.click()
            }
          } else {
            // If already in collapsed mode, just update the view for the selected node
            updateCollapsedViewForSelectedNode()
          }
        }
      })
    })

    // Setup update button handlers
    const updateButtons = document.querySelectorAll('.update-btn')
    console.log('🔧 Setting up event handlers for', updateButtons.length, 'update buttons')

    updateButtons.forEach((btn, index) => {
      console.log(`🔧 Processing button ${index + 1}:`, btn)

      // Skip if already has event handlers
      if (btn.hasAttribute('data-handlers-attached')) {
        console.log(`🔧 Button ${index + 1} already has handlers, skipping`)
        return
      }

      console.log(`🔧 Adding event handler to button ${index + 1}`)
      // Mark as having handlers attached
      btn.setAttribute('data-handlers-attached', 'true')

      btn.addEventListener('click', function () {
        console.log('🚨🚨🚨 UPDATE BUTTON CLICKED! 🚨🚨🚨')
        console.log('Button disabled:', this.disabled)
        console.log('Button element:', this)
        if (this.disabled) {
          console.log('❌ Button is disabled, returning early')
          return
        }

        const nodeId = this.getAttribute('data-node-id')
        const resultType = this.getAttribute('data-result-type')
        console.log('🚨 Node ID:', nodeId, 'Result Type:', resultType)

        // Find the corresponding dropdown to get the selected style
        const dropdown = document.querySelector(`.simple-dropdown[data-node-id="${nodeId}"]`)
        const selectedStyle = dropdown ? dropdown.selectedValue : null
        console.log('🚨 Dropdown:', dropdown, 'Selected Style:', selectedStyle)

        if (selectedStyle && resultType === 'text-style' && nodeId) {
          console.log(`Applying text style "${selectedStyle}" to node ${nodeId}`)

          // Show loading state
          showUpdateButtonLoading(this, selectedStyle)

          // Store the resolved text style for display in resolved tab
          const resolvedTextStates = window.resolvedTextStates || new Map()
          resolvedTextStates.set(nodeId, {
            styleName: selectedStyle,
            displayText: dropdown.querySelector('.dropdown-text')?.textContent || selectedStyle
          })
          window.resolvedTextStates = resolvedTextStates

          parent.postMessage({
            pluginMessage: {
              type: 'apply-text-style',
              nodeId: nodeId,
              styleName: selectedStyle
            }
          }, '*')
        } else if (resultType === 'spacing' && nodeId) {
          console.log('🎯 SPACING UPDATE BUTTON CLICKED!')

          // Get selected token from spacing dropdown
          const spacingDropdown = document.querySelector(`.spacing-dropdown[data-node-id="${nodeId}"]`)
          const selectedToken = spacingDropdown ? spacingDropdown.selectedToken : null

          if (selectedToken) {
            console.log(`Applying spacing token "${selectedToken}" to node ${nodeId}`)

            // Show loading state
            showUpdateButtonLoading(this, selectedToken)

            console.log('🔥 Sending apply-spacing-token message:', {
              type: 'apply-spacing-token',
              nodeId: nodeId,
              tokenName: selectedToken
            });

            parent.postMessage({
              pluginMessage: {
                type: 'apply-spacing-token',
                nodeId: nodeId,
                tokenName: selectedToken
              }
            }, '*')
          } else {
            console.log('No spacing token selected')
          }
        } else if (resultType === 'corner-radius' && nodeId) {
          console.log('🎯 CORNER RADIUS UPDATE BUTTON CLICKED!')

          // Collect all corner radius values from the individual dropdowns
          const cornerDropdowns = document.querySelectorAll(`.corner-radius-dropdown[data-node-id="${nodeId}"]`)
          const cornerTokens = {}
          let hasAnySelection = false

          cornerDropdowns.forEach(dropdown => {
            const corner = dropdown.getAttribute('data-corner')
            const selectedToken = dropdown.selectedToken
            if (selectedToken) {
              cornerTokens[corner] = selectedToken
              hasAnySelection = true
            }
          })

          if (hasAnySelection) {
            console.log(`Applying corner radius tokens to node ${nodeId}:`, cornerTokens)

            // Show loading state
            showUpdateButtonLoading(this, 'corner radius tokens')

            console.log('🔥 Sending apply-corner-radius-tokens message:', {
              type: 'apply-corner-radius-tokens',
              nodeId: nodeId,
              cornerTokens: cornerTokens
            });

            parent.postMessage({
              pluginMessage: {
                type: 'apply-corner-radius-tokens',
                nodeId: nodeId,
                cornerTokens: cornerTokens
              }
            }, '*')
          } else {
            console.log('No corner radius tokens selected')
          }
        } else if (selectedStyle && resultType === 'color' && nodeId) {
          console.log('🎯 COLOR UPDATE BUTTON CLICKED!')
          console.log(`Applying color token "${selectedStyle}" to node ${nodeId}`)

          // Store the resolved color token for display in resolved tab
          const resolvedColorStates = window.resolvedColorStates || new Map()
          resolvedColorStates.set(nodeId, {
            tokenName: selectedStyle,
            displayText: dropdown.querySelector('.dropdown-text')?.textContent || selectedStyle
          })
          window.resolvedColorStates = resolvedColorStates

          // Show loading state
          showUpdateButtonLoading(this, selectedStyle)

          console.log('🔥 Sending apply-color-token message:', {
            type: 'apply-color-token',
            nodeId: nodeId,
            tokenName: selectedStyle
          });

          parent.postMessage({
            pluginMessage: {
              type: 'apply-color-token',
              nodeId: nodeId,
              tokenName: selectedStyle
            }
          }, '*')
        } else {
          console.log('Cannot apply: missing selection, node ID, or unsupported type')
        }
      })
    })

    // Setup corner radius dropdown functionality
    document.querySelectorAll('.corner-radius-dropdown').forEach(dropdown => {
      // Skip if already has event handlers
      if (dropdown.hasAttribute('data-handlers-attached')) {
        return
      }

      // Skip if this is a resolved item (read-only)
      if (dropdown.classList.contains('resolved-readonly')) {
        return
      }

      // Mark as having handlers attached
      dropdown.setAttribute('data-handlers-attached', 'true')
      const input = dropdown.querySelector('.corner-radius-input')
      const optionsContainer = dropdown.querySelector('.corner-dropdown-options')
      const tokenBadge = dropdown.querySelector('.corner-token-badge')
      const tokenContainer = dropdown.querySelector('div[title*="Design System Token"]') // Container for State 1
      const nodeId = dropdown.getAttribute('data-node-id')
      const corner = dropdown.getAttribute('data-corner')

      console.log(`Setting up handlers for ${corner}:`, {
        input: !!input,
        optionsContainer: !!optionsContainer,
        tokenBadge: !!tokenBadge,
        tokenContainer: !!tokenContainer
      })

      // Set up click handlers for different states

      // State 1: Token badge (gray badge inside white container)
      if (tokenBadge && tokenContainer) {
        tokenContainer.addEventListener('click', function (e) {
          e.stopPropagation()

          // Close all other dropdowns first
          document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
            if (opt !== optionsContainer) {
              opt.style.display = 'none'
            }
          })
          document.querySelectorAll('.dropdown-options').forEach(opt => {
            opt.style.display = 'none'
          })

          // Show this dropdown
          optionsContainer.style.display = 'block'
        })

        // Mark that this dropdown has a token selected
        dropdown.selectedToken = tokenBadge.textContent
      }

      // State 2: Input field (hardcoded value or empty)
      if (input) {
        input.addEventListener('click', function (e) {
          e.stopPropagation()

          // Only handle click if input is visible (no token selected)
          if (input.style.display === 'none') {
            return
          }

          // Close all other dropdowns first
          document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
            if (opt !== optionsContainer) {
              opt.style.display = 'none'
            }
          })
          document.querySelectorAll('.dropdown-options').forEach(opt => {
            opt.style.display = 'none'
          })

          // Show this dropdown
          optionsContainer.style.display = 'block'
        })
      }

      // Get corner radius tokens
      const cornerRadiusTokens = getCornerRadiusTokensArray()

      // Populate dropdown options
      optionsContainer.innerHTML = ''

      // Add "Clear Token" option if there's already a token selected
      const clearOption = document.createElement('div')
      clearOption.style.cssText = 'padding: 8px 12px; cursor: pointer; color: #dc2626; transition: background-color 0.2s ease; font-size: 12px; border-bottom: 1px solid #e5e7eb;'
      clearOption.textContent = 'Clear Token'

      clearOption.addEventListener('mouseenter', function () {
        this.style.backgroundColor = '#fef2f2'
      })

      clearOption.addEventListener('mouseleave', function () {
        this.style.backgroundColor = 'white'
      })

      clearOption.addEventListener('click', function () {
        // Set corner radius to hardcoded 0 (which is not considered an issue)
        const corner = dropdown.getAttribute('data-corner')

        // Apply hardcoded 0 value to Figma
        parent.postMessage({
          pluginMessage: {
            type: 'apply-hardcoded-corner-radius',
            nodeId: nodeId,
            corner: corner,
            value: 0
          }
        }, '*')

        // Hide dropdown - UI updates will be handled by the hardcoded-applied message
        optionsContainer.style.display = 'none'
      })

      optionsContainer.appendChild(clearOption)

      cornerRadiusTokens.forEach(token => {
        const option = document.createElement('div')
        option.style.cssText = 'padding: 8px 12px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease; font-size: 12px;'
        option.textContent = token.text
        option.dataset.value = token.value

        option.addEventListener('mouseenter', function () {
          this.style.backgroundColor = '#f3f4f6'
        })

        option.addEventListener('mouseleave', function () {
          this.style.backgroundColor = 'white'
        })

        option.addEventListener('click', function () {
          const selectedValue = this.dataset.value
          const selectedText = this.textContent

          // Extract numeric value from the token name (e.g., "radius-8" -> "8", "8px" -> "8")
          let numericValue = selectedText.match(/\d+/)?.[0] || selectedText

          // Hide the input and show a token badge instead
          input.style.display = 'none'

          // Create or update token badge
          let tokenBadge = dropdown.querySelector('.corner-token-badge')
          if (!tokenBadge) {
            tokenBadge = document.createElement('div')
            tokenBadge.className = 'corner-token-badge'
            dropdown.appendChild(tokenBadge)
          }

          // State 3: User selected Token - Blue background with blue border
          tokenBadge.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
          `
          tokenBadge.className = 'corner-token-badge user-selection'
          tokenBadge.textContent = numericValue
          tokenBadge.setAttribute('title', `Token: ${selectedText} (click to change)`)

          // Add click handler to token badge to reopen dropdown
          tokenBadge.addEventListener('click', function (e) {
            e.stopPropagation()

            // Close all other dropdowns first
            document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
              if (opt !== optionsContainer) {
                opt.style.display = 'none'
              }
            })
            document.querySelectorAll('.dropdown-options').forEach(opt => {
              opt.style.display = 'none'
            })

            // Show this dropdown
            optionsContainer.style.display = 'block'
          })

          // Hide dropdown
          optionsContainer.style.display = 'none'

          // Enable update button with proper styling
          const updateBtn = document.querySelector(`.update-btn[data-node-id="${nodeId}"]`)
          if (updateBtn) {
            updateBtn.disabled = false
            updateBtn.style.background = '#3b82f6'
            updateBtn.style.color = 'white'
            updateBtn.style.cursor = 'pointer'
          }

          // Store the selected token for the update button
          dropdown.selectedToken = selectedValue

          // Close all other corner radius dropdowns
          document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
            if (opt !== optionsContainer) {
              opt.style.display = 'none'
            }
          })
        })

        optionsContainer.appendChild(option)
      })

      // Input click handler is now set up above in the main setup section

      // Prevent text selection and typing
      if (input) {
        input.addEventListener('keydown', function (e) {
          e.preventDefault()
        })

        input.addEventListener('keypress', function (e) {
          e.preventDefault()
        })
      }
    })

    // Setup spacing dropdown functionality
    document.querySelectorAll('.spacing-dropdown').forEach(dropdown => {
      // Skip if already has event handlers
      if (dropdown.hasAttribute('data-handlers-attached')) {
        return
      }

      // Skip if this is a resolved item (read-only)
      if (dropdown.classList.contains('resolved-readonly')) {
        return
      }

      // Mark as having handlers attached
      dropdown.setAttribute('data-handlers-attached', 'true')
      const spacingElement = dropdown.querySelector('div[style*="background: white"]')
      const optionsContainer = dropdown.querySelector('.spacing-dropdown-options')
      const nodeId = dropdown.getAttribute('data-node-id')

      if (spacingElement && optionsContainer) {
        // Add click handler to spacing element
        spacingElement.addEventListener('click', function (e) {
          e.stopPropagation()

          // Close all other dropdowns first
          document.querySelectorAll('.spacing-dropdown-options').forEach(opt => {
            if (opt !== optionsContainer) {
              opt.style.display = 'none'
            }
          })
          document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
            opt.style.display = 'none'
          })
          document.querySelectorAll('.dropdown-options').forEach(opt => {
            opt.style.display = 'none'
          })

          // Populate and show this dropdown
          populateSpacingDropdown(optionsContainer, nodeId, dropdown)
          optionsContainer.style.display = 'block'
        })
      }
    })

    // Close corner radius and spacing dropdowns when clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.corner-radius-dropdown') && !e.target.closest('.spacing-dropdown')) {
        document.querySelectorAll('.corner-dropdown-options').forEach(opt => {
          opt.style.display = 'none'
        })
        document.querySelectorAll('.spacing-dropdown-options').forEach(opt => {
          opt.style.display = 'none'
        })
      }
    })
  }

  function populateSpacingDropdown(optionsContainer, nodeId, dropdown) {
    // Get spacing tokens
    const spacingTokens = getSpacingTokensArray()

    // Clear existing options
    optionsContainer.innerHTML = ''

    // Add clear option
    const clearOption = document.createElement('div')
    clearOption.style.cssText = 'padding: 8px 12px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease; font-size: 12px; border-bottom: 1px solid #e5e7eb;'
    clearOption.textContent = 'Clear Token'

    clearOption.addEventListener('mouseenter', function () {
      this.style.backgroundColor = '#fef2f2'
    })

    clearOption.addEventListener('mouseleave', function () {
      this.style.backgroundColor = 'white'
    })

    clearOption.addEventListener('click', function () {
      // Apply hardcoded spacing value (this would need backend support)
      console.log('Clear spacing token clicked for node:', nodeId)

      // Hide dropdown
      optionsContainer.style.display = 'none'

      // For now, just hide the dropdown - would need backend implementation
      showSuccessNotification('Spacing cleared')
    })

    optionsContainer.appendChild(clearOption)

    // Add spacing token options
    spacingTokens.forEach(token => {
      const option = document.createElement('div')
      option.style.cssText = 'padding: 8px 12px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease; font-size: 12px;'
      option.textContent = token.text
      option.dataset.value = token.value

      option.addEventListener('mouseenter', function () {
        this.style.backgroundColor = '#f3f4f6'
      })

      option.addEventListener('mouseleave', function () {
        this.style.backgroundColor = 'white'
      })

      option.addEventListener('click', function () {
        const selectedValue = this.dataset.value
        const selectedText = this.textContent

        console.log(`Spacing token selected: ${selectedValue} (${selectedText})`)

        // Update the spacing element to show selected token
        const spacingElement = dropdown.querySelector('div[style*="background: white"]')
        if (spacingElement) {
          // Extract just the numeric value from the token name
          const numericValue = selectedText.match(/\d+/)?.[0] || selectedText

          // Update the value span (second span)
          const valueSpan = spacingElement.querySelectorAll('span')[1]
          if (valueSpan) {
            valueSpan.textContent = numericValue
          }

          // Update styling to show it's now a token
          spacingElement.style.background = '#f3f4f6'
          spacingElement.style.borderColor = '#10b981'
          spacingElement.setAttribute('title', `Design System Token: ${selectedText}`)
        }

        // Store selected token
        dropdown.selectedToken = selectedValue

        // Hide dropdown
        optionsContainer.style.display = 'none'

        // Enable update button
        const updateBtn = document.querySelector(`.update-btn[data-node-id="${nodeId}"]`)
        if (updateBtn) {
          updateBtn.disabled = false
          updateBtn.style.background = '#3b82f6'
          updateBtn.style.color = 'white'
          updateBtn.style.cursor = 'pointer'
        }
      })

      optionsContainer.appendChild(option)
    })
  }

  // Helper function to reset corner radius input appearance
  function resetCornerRadiusInputAppearance(input) {
    input.style.backgroundColor = 'white'
    input.style.borderColor = '#d1d5db'
    input.style.color = '#374151'
    input.style.fontWeight = 'normal'
    input.removeAttribute('data-has-token')
    input.removeAttribute('title')
  }

  // Helper function to set corner radius input token appearance
  function setCornerRadiusTokenAppearance(input, tokenName) {
    input.style.backgroundColor = '#ecfdf5'
    input.style.borderColor = '#10b981'
    input.style.color = '#065f46'
    input.style.fontWeight = '600'
    input.setAttribute('data-has-token', 'true')
    input.setAttribute('title', `Token: ${tokenName}`)
  }

  function shouldShowIgnoreButton() {
    const currentStatusFilter = window.currentStatusFilter || 'active'
    // Only show ignore button for active issues
    return currentStatusFilter === 'active'
  }

  function displayValidationResults(results) {
    console.log('displayValidationResults called with:', results)
    const content = document.getElementById('validation-results-content')
    console.log('Content element:', content)

    // Use the results as-is since filtering is handled by applyFilters
    const filteredResults = results

    console.log(`Displaying ${filteredResults.length} results`)

    if (filteredResults.length === 0) {
      const currentStatusFilter = window.currentStatusFilter || 'active'
      let emptyMessage = ''

      if (currentStatusFilter === 'active') {
        emptyMessage = `
          <div style="text-align: center; padding: 40px 16px; color: #28a745;">
            <div style="font-size: 32px; margin-bottom: 12px;">🎉</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 6px; color: #111827;">All Issues Resolved!</div>
            <div style="font-size: 14px; color: #6b7280;">Your design is now compliant with the design system.</div>
          </div>`
      } else if (currentStatusFilter === 'resolved') {
        emptyMessage = `
          <div style="text-align: center; padding: 40px 16px; color: #6b7280;">
            <div style="font-size: 32px; margin-bottom: 12px;">📋</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 6px; color: #111827;">No Resolved Issues</div>
            <div style="font-size: 14px; color: #6b7280;">Issues you fix will appear here.</div>
          </div>`
      } else if (currentStatusFilter === 'ignored') {
        emptyMessage = `
          <div style="text-align: center; padding: 40px 16px; color: #6b7280;">
            <div style="font-size: 32px; margin-bottom: 12px;">🙈</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 6px; color: #111827;">No Ignored Issues</div>
            <div style="font-size: 14px; color: #6b7280;">Issues you ignore will appear here.</div>
          </div>`
      }

      content.innerHTML = emptyMessage
      return
    }

    let html = ''
    filteredResults.forEach((result, index) => {
      const isSpacing = result.type === 'spacing'
      const isCornerRadius = result.type === 'corner-radius'
      const isColor = result.type === 'color'
      const isLastItem = index === filteredResults.length - 1

      // Component badge styling based on type - more compact
      let badgeStyle = ''
      if (isSpacing) {
        badgeStyle = 'background: #fed7aa; color: #c2410c; padding: 2px 6px; font-size: 11px; font-weight: 500; border-radius: 3px;'
      } else if (isCornerRadius) {
        badgeStyle = 'background: #fef3c7; color: #f59e0b; padding: 2px 6px; font-size: 11px; font-weight: 500; border-radius: 3px;'
      } else if (isColor) {
        badgeStyle = 'background: #fce7f3; color: #be185d; padding: 2px 6px; font-size: 11px; font-weight: 500; border-radius: 3px;'
      } else {
        badgeStyle = 'background: #dbeafe; color: #1d4ed8; padding: 2px 6px; font-size: 11px; font-weight: 500; border-radius: 3px;'
      }

      // Different dropdown text based on result type
      let dropdownText = 'Select a style...'
      if (isSpacing) {
        dropdownText = 'Select token...'
      } else if (isCornerRadius) {
        dropdownText = 'Select radius...'
      } else if (isColor) {
        dropdownText = 'Select color...'
      }

      // Simplified template literal to avoid syntax errors
      const borderStyle = !isLastItem ? 'border-bottom: 1px solid #e5e7eb;' : '';
      const nodeId = result.node?.id || '';
      const resultType = result.type;

      html += `
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; ${borderStyle} transition: background-color 0.15s;" 
             onmouseover="this.style.backgroundColor='#f9fafb'" 
             onmouseout="this.style.backgroundColor='white'">
          <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0;">
            <span style="${badgeStyle}; max-width: 480px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${result.frameName}">${truncateFrameName(result.frameName)}</span>
            <span style="font-size: 14px; color: #374151; line-height: 1.4; flex: 1;" title="${result.issue}">${result.issue}</span>
          </div>
          
          <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">`;

      // Add corner radius inputs with dropdown functionality
      if (isCornerRadius) {
        console.log('Corner radius result:', result)
        console.log('Corner values:', result.cornerValues)
        // Helper function to create corner element (input or badge)
        const createCornerElement = (corner, cornerData, placeholder) => {
          console.log(`Creating corner element: ${corner}, cornerData:`, cornerData)

          // Check if we're in resolved tab to disable interactivity
          const currentStatusFilter = window.currentStatusFilter || 'active'
          const isResolved = currentStatusFilter === 'resolved'

          // Handle both old format (just value) and new format (object with value and hasToken)
          let value, hasToken;
          if (cornerData && typeof cornerData === 'object' && cornerData.value !== undefined) {
            value = cornerData.value;
            hasToken = cornerData.hasToken;
          } else {
            value = cornerData;
            hasToken = false; // Default to no token for backward compatibility
          }

          if (typeof value === 'number' || (value && String(value).trim() !== '')) {
            if (hasToken) {
              // State 1: Value has Token - Compact gray badge inside white container
              const cursor = isResolved ? 'default' : 'pointer'
              const title = isResolved ? `Design System Token: ${value}` : `Design System Token: ${value} (click to change)`

              return `
                <div class="corner-radius-dropdown ${isResolved ? 'resolved-readonly' : ''}" data-node-id="${nodeId}" data-corner="${corner}" style="position: relative;">
                  <div style="background: white; border: 1px solid #d1d5db; border-radius: 3px; padding: 4px; width: 40px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: ${cursor};" title="${title}">
                    <span class="corner-token-badge existing-token">${value}</span>
                  </div>
                  ${isResolved ? '' : `<div class="corner-dropdown-options" style="position: absolute; top: 100%; left: 0; min-width: 120px; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
                    <!-- Options will be populated by JavaScript -->
                  </div>`}
                </div>`;
            } else {
              // State 2: Hardcoded value (not a token) - Add red outline for non-zero values
              const isZero = value === 0 || value === '0'
              const cssClass = isZero ? 'hardcoded-zero' : 'hardcoded-nonzero'
              const cursor = isResolved ? 'default' : 'pointer'
              const title = isResolved ? `Hardcoded value: ${value}` : `Hardcoded value: ${value} (click to convert to token)`

              return `
                <div class="corner-radius-dropdown ${isResolved ? 'resolved-readonly' : ''}" data-node-id="${nodeId}" data-corner="${corner}" style="position: relative;">
                  <input type="text" value="${value}" class="corner-radius-input ${cssClass}" readonly style="width: 40px; height: 24px; font-size: 11px; text-align: center; cursor: ${cursor}; background: white; color: #111827;" title="${title}">
                  ${isResolved ? '' : `<div class="corner-dropdown-options" style="position: absolute; top: 100%; left: 0; min-width: 120px; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
                    <!-- Options will be populated by JavaScript -->
                  </div>`}
                </div>`;
            }
          } else {
            // Show input field for empty values
            const cursor = isResolved ? 'default' : 'pointer'

            return `
              <div class="corner-radius-dropdown ${isResolved ? 'resolved-readonly' : ''}" data-node-id="${nodeId}" data-corner="${corner}" style="position: relative;">
                <input type="text" value="" class="corner-radius-input" placeholder="${placeholder}" readonly style="width: 40px; height: 24px; font-size: 11px; text-align: center; border: 1px solid #d1d5db; border-radius: 3px; cursor: ${cursor}; background: white;">
                ${isResolved ? '' : `<div class="corner-dropdown-options" style="position: absolute; top: 100%; left: 0; min-width: 120px; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
                  <!-- Options will be populated by JavaScript -->
                </div>`}
              </div>`;
          }
        };

        html += `
            <div style="display: flex; flex-direction: column; gap: 8px; margin-right: 8px;">
              <div style="display: flex; gap: 8px;">
                ${createCornerElement('topLeft', result.cornerValues?.topLeftRadius, 'TL')}
                ${createCornerElement('topRight', result.cornerValues?.topRightRadius, 'TR')}
              </div>
              <div style="display: flex; gap: 8px;">
                ${createCornerElement('bottomLeft', result.cornerValues?.bottomLeftRadius, 'BL')}
                ${createCornerElement('bottomRight', result.cornerValues?.bottomRightRadius, 'BR')}
              </div>
            </div>`;

        // Buttons should start disabled and only be enabled when users select tokens

      } else if (isSpacing) {
        // Special spacing visual element
        const currentStatusFilter = window.currentStatusFilter || 'active'
        const isResolved = currentStatusFilter === 'resolved'
        const cursor = isResolved ? 'default' : 'pointer'
        const spacingValue = result.value || '20' // Use actual spacing value

        html += `
            <div class="spacing-dropdown ${isResolved ? 'resolved-readonly' : ''}" data-node-id="${nodeId}" data-result-type="${resultType}" style="position: relative;">
              <div style="background: white; border: 1px solid #d1d5db; border-radius: 3px; display: inline-flex; align-items: center; padding: 6px 8px; cursor: ${cursor}; gap: 8px;" title="${isResolved ? `Spacing: ${spacingValue}px` : `Hardcoded spacing: ${spacingValue}px (click to convert to token)`}">
                <span style="color: #d1d5db; font-size: 12px; font-weight: 500; display: inline-flex; align-items: center;">
                  ]<span style="font-size: 10px; margin: 0 0px;">|</span>[
                </span>
                <span style="color: #111827; font-size: 12px; font-weight: 500;">${spacingValue}</span>
                ${isResolved ? '' : `<svg style="width: 12px; height: 12px; color: #6b7280;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path d="m6 9 6 6 6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>`}
              </div>
              ${isResolved ? '' : `<div class="spacing-dropdown-options" style="position: absolute; top: 100%; left: 0; min-width: 200px; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
                <!-- Options will be populated by JavaScript -->
              </div>`}
            </div>`;
      } else {
        // Other types use simple dropdown
        const dropdownWidth = isColor ? '140px' : '200px';
        html += `
            <div class="simple-dropdown" data-node-id="${nodeId}" data-result-type="${resultType}" style="position: relative;">
              <button class="dropdown-trigger" style="display: flex; align-items: center; gap: 6px; padding: 4px 12px; font-size: 13px; color: #6b7280; background: transparent; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer; transition: all 0.15s; min-width: ${dropdownWidth};">
                <span class="dropdown-text">${dropdownText}</span>
                <svg class="dropdown-arrow" style="width: 12px; height: 12px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path d="m6 9 6 6 6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <div class="dropdown-options" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #d1d5db; border-radius: 4px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); z-index: 1000; max-height: 200px; overflow-y: auto; display: none; margin-top: 2px;">
                <!-- Options will be populated by JavaScript -->
              </div>
            </div>`;
      }

      // Only show update button for active items, not resolved items
      const currentStatusFilter = window.currentStatusFilter || 'active'
      if (currentStatusFilter === 'active') {
        html += `
            <button class="update-btn" data-node-id="${nodeId}" data-result-type="${resultType}" disabled 
                    style="padding: 4px 12px; font-size: 13px; font-weight: 500; color: #6b7280; background: #f3f4f6; border: none; border-radius: 4px; cursor: not-allowed; transition: all 0.15s;">
              Update
            </button>`;
      }
      // For resolved items, don't show any button since being in the resolved tab already indicates status

      // Add ignore button if needed
      if (shouldShowIgnoreButton()) {
        html += `
            <button class="ignore-btn" data-node-id="${nodeId}" style="padding: 4px 12px; font-size: 13px; font-weight: 500; color: #dc2626; background: transparent; border: none; border-radius: 4px; cursor: pointer; transition: all 0.15s;"
                    onmouseover="this.style.backgroundColor='#fef2f2'" 
                    onmouseout="this.style.backgroundColor='transparent'">
              Ignore
            </button>`;
      }

      html += `
            <button class="view-node-btn" data-node-id="${nodeId}" 
                    style="padding: 4px; background: transparent; border: none; border-radius: 3px; cursor: pointer; transition: all 0.15s;"
                    onmouseover="this.style.backgroundColor='#f3f4f6'" 
                    onmouseout="this.style.backgroundColor='transparent'">
              <svg style="width: 14px; height: 14px; color: #6b7280;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <circle cx="12" cy="12" r="3"/>
              </svg>
            </button>
          </div>
        </div>`;
    })

    content.innerHTML = html

    // Add event handlers for dropdowns and update buttons
    setupValidationEventHandlers()

    // Add ignore button handlers (only if they exist)
    document.querySelectorAll('.ignore-btn').forEach(btn => {
      btn.addEventListener('click', function () {
        const nodeId = this.dataset.nodeId
        if (nodeId) {
          ignoreIssue(nodeId)
        }
      })
    })
  }

  // Tab handlers
  document.addEventListener('click', (e) => {
    // Category tab handler
    if (e.target.classList.contains('category-tab-button')) {
      console.log('Category tab clicked:', e.target.dataset.tab)

      // Remove active class from all category tabs
      document.querySelectorAll('.category-tab-button').forEach(tab => {
        tab.classList.remove('active')
      })

      // Add active class to clicked tab
      e.target.classList.add('active')

      // Store current category filter
      window.currentCategoryFilter = e.target.dataset.tab

      // Apply both category and status filters
      applyFilters()
    }

    // Status tab handler
    if (e.target.classList.contains('status-tab-button')) {
      console.log('Status tab clicked:', e.target.dataset.status)

      // Remove active class from all status tabs
      document.querySelectorAll('.status-tab-button').forEach(tab => {
        tab.classList.remove('active')
      })

      // Add active class to clicked tab
      e.target.classList.add('active')

      // Store current status filter
      window.currentStatusFilter = e.target.dataset.status

      // Apply both category and status filters
      applyFilters()
    }
  })

  // Hover effects are handled by CSS (.tab-button:hover)

  // Back to validation handler
  const backToValidationBtn = document.getElementById('back-to-validation')
  if (backToValidationBtn) {
    backToValidationBtn.onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'back-to-validation' } }, '*')
      showScreen('home')
    }
  }

  // Export instructions screen handlers
  const gotItBtn = document.getElementById('got-it-btn')
  if (gotItBtn) {
    gotItBtn.onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'user-going-to-design-system' } }, '*')
    }
  }

  // Export confirmation screen handlers
  const returnToFilesBtn = document.getElementById('return-to-files')
  if (returnToFilesBtn) {
    returnToFilesBtn.onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'close-plugin' } }, '*')
    }
  }

  // Function to dynamically resize window based on content height
  function resizeWindowToContent() {
    try {
      // Get the main content container
      const body = document.body
      const activeScreen = document.querySelector('.screen.active')

      if (!activeScreen) return

      // Calculate the required height more accurately
      const contentHeight = activeScreen.scrollHeight
      const bodyHeight = body.scrollHeight
      let windowHeight = Math.max(contentHeight, bodyHeight)

      // Account for sticky footer on home screen
      const stickyFooter = document.getElementById('home-sticky-footer')
      const isHomeScreen = activeScreen.id === 'home-screen'
      if (isHomeScreen && stickyFooter) {
        const footerHeight = 140 // Height of sticky footer area
        windowHeight = Math.max(windowHeight, contentHeight + footerHeight)
      }

      // More generous padding to account for margins, borders, etc.
      const padding = 80 // Increased padding for better spacing
      const minHeight = 500 // Increased minimum height
      const maxHeight = 1200 // Increased maximum height for more content

      // Calculate optimal height with more generous constraints
      let optimalHeight = Math.max(minHeight, Math.min(maxHeight, windowHeight + padding))

      // Get current width (maintain existing width)
      const currentWidth = window.innerWidth || 400

      console.log(`📏 Resizing window - Content: ${contentHeight}px, Body: ${bodyHeight}px, Window: ${windowHeight}px, Optimal: ${optimalHeight}px, Home: ${isHomeScreen}`)

      // Send resize message to plugin
      parent.postMessage({
        pluginMessage: {
          type: 'resize-ui',
          width: currentWidth,
          height: optimalHeight
        }
      }, '*')

    } catch (error) {
      console.error('Error resizing window:', error)
    }
  }

  // Immediately hide all screens on page load
  document.addEventListener('DOMContentLoaded', () => {
    console.log('🧹 Clearing all screens on page load')
    document.querySelectorAll('.screen').forEach(screen => {
      screen.classList.remove('active')
      console.log('Cleared screen:', screen.id)
    })
  })

  // Also run immediately if DOM is already loaded
  if (document.readyState !== 'loading') {
    console.log('🧹 Clearing all screens immediately (DOM already loaded)')
    document.querySelectorAll('.screen').forEach(screen => {
      screen.classList.remove('active')
      console.log('Cleared screen:', screen.id)
    })
  }

  // Handle messages from plugin
  window.onmessage = (event) => {
    const msg = event.data.pluginMessage

    if (msg.type === 'ui-mode') {
      console.log('UI received mode:', msg.mode)
      showScreen(msg.mode)

      // Request resize to match the screen
      parent.postMessage({
        pluginMessage: {
          type: 'resize-ui',
          sizeMode: msg.mode
        }
      }, '*')
      if (msg.mode === 'export') {
        document.getElementById('file-name').textContent = msg.fileName
      }
      if (msg.mode === 'selection') {
        // Initialize custom dropdown and request saved libraries when showing selection screen
        setTimeout(() => {
          initializeCustomDropdown()
          // Fixed height - no dynamic resizing needed
          // resizeWindowToContent()
        }, 200)
        parent.postMessage({ pluginMessage: { type: 'get-saved-libraries' } }, '*')
      }
      if (msg.mode === 'home') {
        // Setup checkbox interactions when home screen is shown
        setTimeout(() => {
          setupCheckboxInteractions()
          initializeCustomDropdown()
          // Fixed height - no dynamic resizing needed
          // resizeWindowToContent()
        }, 200)
      }
    }

    if (msg.type === 'keys-exported') {
      // Update export details and show confirmation screen
      const textStylesCount = msg.textStylesCount || msg.count
      const variablesCount = msg.variablesCount || 0

      let exportMessage = `Exported <span style="color: white; font-weight: 600;">${textStylesCount} text style keys</span>`
      if (variablesCount > 0) {
        exportMessage += ` and <span style="color: white; font-weight: 600;">${variablesCount} variables</span>`
      }
      exportMessage += ` from <span style="color: white; font-weight: 600;">${msg.libraryName}</span><br>Saved as: <span style="color: #10B981; font-weight: 600;">${msg.fileName}</span>`

      document.getElementById('export-details').innerHTML = exportMessage
      parent.postMessage({
        pluginMessage: {
          type: 'switch-mode',
          mode: 'export-confirmation'
        }
      }, '*')
    }

    if (msg.type === 'saved-libraries') {
      const librariesWithCount = msg.libraries.map(lib => ({
        key: lib.key,
        name: lib.displayName || `${lib.name} (${lib.count} styles)`
      }))

      // Update custom dropdown for home screen
      if (homeLibraryDropdown) {
        homeLibraryDropdown.setLibraries(librariesWithCount)
      }

      // Update custom dropdown for selection screen
      if (selectionLibraryDropdown) {
        selectionLibraryDropdown.setLibraries(librariesWithCount)
      }
    }

    if (msg.type === 'library-selected') {
      // Update home screen with selected library info
      const libraryNameElement = document.getElementById('selected-library-name')

      if (msg.library) {
        // Update custom dropdown
        if (homeLibraryDropdown) {
          homeLibraryDropdown.setValue(msg.library.key, `${msg.library.name} Attached`)
        }

        // Fallback for native select if it exists
        if (libraryNameElement) {
          libraryNameElement.textContent = `${msg.library.name} Attached`
        }

        // Update all token counts if tokenCounts are available
        if (msg.library.tokenCounts) {
          const counts = msg.library.tokenCounts

          // Update existing counts
          const textStylesElement = document.getElementById('text-styles-count')
          if (textStylesElement) {
            textStylesElement.textContent = `${counts.textStyles} Styles Available`
          }

          const spacingElement = document.getElementById('spacing-variables-count')
          if (spacingElement) {
            spacingElement.textContent = `${counts.spacing} Variables Available`
          }

          // Update token counts and show/hide validation options based on availability
          const updateCountAndVisibility = (checkboxId, countId, count, label) => {
            const countElement = document.getElementById(countId)
            const checkboxGroup = document.querySelector(`label[for="${checkboxId}"]`)

            if (countElement) {
              countElement.textContent = `${count} ${label}`
            }

            // Show/hide the entire validation option based on token availability
            if (checkboxGroup) {
              if (count > 0) {
                checkboxGroup.style.display = 'flex'
              } else {
                checkboxGroup.style.display = 'none'
                // Uncheck the checkbox if hidden
                const checkbox = document.getElementById(checkboxId)
                if (checkbox) {
                  checkbox.checked = false
                }
              }
            }
          }

          // Always show text styles and spacing (core functionality)
          const coreTextStylesElement = document.getElementById('text-styles-count')
          if (coreTextStylesElement) {
            coreTextStylesElement.textContent = `${counts.textStyles} Styles Available`
          }

          const coreSpacingElement = document.getElementById('spacing-variables-count')
          if (coreSpacingElement) {
            coreSpacingElement.textContent = `${counts.spacing} Variables Available`
          }

          // Update other token types with visibility logic
          updateCountAndVisibility('colors-checkbox', 'colors-count', counts.colors, 'Colors Available')
          updateCountAndVisibility('corner-radius-checkbox', 'corner-radius-count', counts.cornerRadius, 'Radius Tokens Available')
          updateCountAndVisibility('typography-checkbox', 'typography-count', counts.typography, 'Typography Tokens Available')
          updateCountAndVisibility('shadows-checkbox', 'shadows-count', counts.shadows, 'Shadow Tokens Available')
          updateCountAndVisibility('borders-checkbox', 'borders-count', counts.borders, 'Border Tokens Available')
          updateCountAndVisibility('opacity-checkbox', 'opacity-count', counts.opacity, 'Opacity Tokens Available')
          updateCountAndVisibility('sizing-checkbox', 'sizing-count', counts.sizing, 'Sizing Tokens Available')
        } else {
          // Fallback for older format
          const fallbackTextStylesElement = document.getElementById('text-styles-count')
          if (fallbackTextStylesElement) {
            fallbackTextStylesElement.textContent = `${msg.library.textStylesCount || msg.library.count} Styles Available`
          }

          const fallbackSpacingElement = document.getElementById('spacing-variables-count')
          if (fallbackSpacingElement) {
            fallbackSpacingElement.textContent = `${msg.library.spacingVariablesCount || 0} Variables Available`
          }
        }

        // Fixed height - no dynamic resizing needed
        // setTimeout(resizeWindowToContent, 100)
        // setTimeout(resizeWindowToContent, 300)
        // setTimeout(resizeWindowToContent, 500)
      }
    }

    if (msg.type === 'libraries-cleared') {
      showScreen('link')
    }

    if (msg.type === 'text-styles-data') {
      showTextStylesScreen(msg.textStyles)
    }

    if (msg.type === 'spacing-variables-data') {
      showSpacingVariablesScreen(msg.spacingVariables)
    }

    if (msg.type === 'colors-data') {
      showColorsScreen(msg.colors)
    }

    if (msg.type === 'corner-radius-data') {
      showCornerRadiusScreen(msg.cornerRadius)
    }

    if (msg.type === 'validation-results') {
      showValidationResults(msg.results, msg.library, msg.targetName, msg.targetType, msg.options)
    }

    if (msg.type === 'selection-changed') {
      console.log('Selection changed:', msg.nodeId)
      window.currentSelectedNodeId = msg.nodeId

      // Update collapsed view if we're in minimized state
      if (window.isValidationMinimized) {
        updateCollapsedViewForSelectedNode()
      }
    }

    if (msg.type === 'validation-error') {
      console.error('Validation error received:', msg.error)
      const content = document.getElementById('validation-results-content')
      if (content) {
        content.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #dc3545;">
            <div style="font-size: 18px; margin-bottom: 16px;">⚠️ Validation Failed</div>
            <div style="color: #666; margin-bottom: 24px;">${msg.error}</div>
            <button onclick="goBackToHome()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Try Again
            </button>
          </div>
        `
      }
    }

    if (msg.type === 'hardcoded-applied') {
      if (msg.ok) {
        // Handle hardcoded value application (like setting corner to 0)
        console.log('Hardcoded value applied successfully:', msg)

        // Update the specific corner UI to show the hardcoded value
        const cornerDropdown = document.querySelector(`.corner-radius-dropdown[data-node-id="${msg.nodeId}"][data-corner="${msg.corner}"]`)
        if (cornerDropdown) {
          const input = cornerDropdown.querySelector('.corner-radius-input')
          if (input) {
            // Set the value to the hardcoded value (e.g., "0")
            input.value = String(msg.value)
            input.style.display = 'block'

            // Apply hardcoded value styling with CSS classes
            const isZero = msg.value === 0 || msg.value === '0'
            const cssClass = isZero ? 'hardcoded-zero' : 'hardcoded-nonzero'

            // Remove existing hardcoded classes and add the appropriate one
            input.classList.remove('hardcoded-zero', 'hardcoded-nonzero')
            input.classList.add(cssClass)

            // Apply base styling
            input.style.cssText = 'width: 40px; height: 24px; font-size: 11px; text-align: center; cursor: pointer; background: white; color: #111827;'
            input.setAttribute('title', `Hardcoded value: ${msg.value} (click to convert to token)`)
            input.setAttribute('readonly', 'true')
          }

          // Remove any token badges since this is now a hardcoded value
          const tokenBadge = cornerDropdown.querySelector('.corner-token-badge')
          if (tokenBadge) {
            tokenBadge.remove()
          }

          // Clear selected token since this is now hardcoded
          cornerDropdown.selectedToken = null

          // Mark that this corner no longer has an existing token
          cornerDropdown.hasExistingToken = false
        }

        // Check if all corners are now resolved (either have tokens or are 0)
        checkAndResolveCornerRadiusItem(msg.nodeId)
      } else {
        // Handle error
        console.error('❌ Hardcoded value application failed:', msg.error)
        figma.notify(msg.error || 'Failed to apply hardcoded value', { error: true })
      }
    } else if (msg.type === 'applied') {
      if (msg.ok) {
        // Success - show visual feedback
        console.log('Style applied successfully:', msg)
        showStyleAppliedFeedback(msg.nodeId, msg.styleName, msg.targetType, msg.appliedCorners, msg.isCornerRadius)
      } else {
        // Error - show error message
        console.error('❌ Style application failed:', msg.error)

        // Provide more helpful error messages for common issues
        let errorMessage = msg.error;
        if (msg.error.includes('Variable with ID') && msg.error.includes('not found')) {
          errorMessage = `${msg.error}\n\n💡 This usually happens when:\n• The design system has been updated\n• Variables were deleted or recreated\n• You're in a different file than the design system\n\nTry re-exporting your design system or check if you're in the correct file.`;
        } else if (msg.error.includes('not accessible in this file')) {
          errorMessage = `${msg.error}\n\n💡 Make sure you're working in the same file as your design system, or that the design system is properly linked to this file.`;
        }

        // Show error in a more user-friendly way
        const shouldRetry = confirm(`${errorMessage}\n\nWould you like to try refreshing the design system data?`);
        if (shouldRetry) {
          // Suggest going back to export screen to refresh data
          parent.postMessage({ pluginMessage: { type: 'switch-mode', mode: 'export' } }, '*');
        }

        // Reset button state if we have nodeId
        if (msg.nodeId) {
          resetUpdateButton(msg.nodeId)
        }
      }
    }
  }

  // Track current selected node and minimized state
  window.currentSelectedNodeId = null
  window.isValidationMinimized = false

  // Function to update collapsed view for selected node (global scope)
  function updateCollapsedViewForSelectedNode() {
    console.log('🔍 updateCollapsedViewForSelectedNode called')
    const collapsedContent = document.getElementById('selected-node-issues')
    const validationResults = window.validationResults || []
    const updatedItems = window.updatedItems || new Set()

    console.log('🔍 Collapsed content element:', collapsedContent)
    console.log('🔍 Validation results:', validationResults.length, 'items')
    console.log('🔍 Current selected node ID:', window.currentSelectedNodeId)

    if (!collapsedContent) {
      console.log('❌ No collapsed content element found')
      return
    }

    if (!window.currentSelectedNodeId) {
      console.log('🔍 No selected node, showing default message')
      collapsedContent.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 60px; color: #999; font-style: italic; background: white; border: 1px solid #e5e7eb; margin: 16px;">Select an asset in Figma to see its validation issues</div>'
      return
    }

    // Find issues for the selected node (based on current status filter)
    const issueStates = window.issueStates || new Map()
    const currentStatusFilter = window.currentStatusFilter || 'active'

    const nodeIssues = validationResults.filter(result => {
      const nodeId = result.node?.id
      if (nodeId !== window.currentSelectedNodeId) return false

      const issueState = issueStates.get(nodeId) || 'active'
      return issueState === currentStatusFilter
    })

    if (nodeIssues.length === 0) {
      console.log('🔍 No issues found for selected node')
      collapsedContent.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 60px; color: #28a745; font-weight: 500; background: white; border: 1px solid #e5e7eb; margin: 16px;">✓ No issues found for selected asset</div>'
      return
    }

    // Display the issues in the exact same format as expanded view
    let html = ''

    nodeIssues.forEach((result, index) => {
      const isSpacing = result.type === 'spacing'
      const isCornerRadius = result.type === 'corner-radius'
      const isColor = result.type === 'color'

      let frameNameColor = '#007bff'
      let dropdownText = 'Select a style...'

      if (isSpacing) {
        frameNameColor = '#ff8c00'
        dropdownText = 'Select token...'
      } else if (isCornerRadius) {
        frameNameColor = '#f59e0b'
        dropdownText = 'Select radius...'
      } else if (isColor) {
        frameNameColor = '#be185d'
        dropdownText = 'Select color...'
      }

      html += `
          <div style="display: flex; align-items: center; padding: 12px 16px; border-bottom: 1px solid #f1f3f4; background: white;">
            <div style="color: ${frameNameColor}; font-weight: 500; font-size: 13px; min-width: 80px; max-width: 480px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${result.frameName}">${truncateFrameName(result.frameName)}</div>

            <div style="flex: 1; color: #6c757d; font-size: 14px; margin-right: 16px;" title="${result.issue}">- ${result.issue}</div>
            <div style="display: flex; gap: 8px; margin-right: 12px; position: relative;">
              ${isCornerRadius ? `
              <!-- Corner radius input fields (simplified) -->
              <div style="display: flex; flex-direction: column; gap: 6px; margin-right: 8px;">
                <div style="display: flex; gap: 6px;">
                  <div style="display: flex; align-items: center; gap: 3px;">
                    <span style="width: 5px; height: 5px; border-left: 2px solid #e5e7eb; border-top: 2px solid #e5e7eb; border-radius: 1px 0 0 0;"></span>
                    <input type="text" value="${result.cornerValues?.topLeftRadius || ''}" 
                           ${result.cornerValues?.topLeftRadius ? '' : 'disabled'} 
                           style="width: 24px; height: 20px; font-size: 10px; text-align: center; border: 1px solid #d1d5db; border-radius: 2px; outline: none;">
                  </div>
                  <div style="display: flex; align-items: center; gap: 3px;">
                    <input type="text" value="${result.cornerValues?.topRightRadius || ''}" 
                           ${result.cornerValues?.topRightRadius ? '' : 'disabled'} 
                           style="width: 24px; height: 20px; font-size: 10px; text-align: center; border: 1px solid #d1d5db; border-radius: 2px; outline: none;">
                    <span style="width: 5px; height: 5px; border-right: 2px solid #e5e7eb; border-top: 2px solid #e5e7eb; border-radius: 0 1px 0 0;"></span>
                  </div>
                </div>
                <div style="display: flex; gap: 6px;">
                  <div style="display: flex; align-items: center; gap: 3px;">
                    <span style="width: 5px; height: 5px; border-left: 2px solid #e5e7eb; border-bottom: 2px solid #e5e7eb; border-radius: 0 0 0 1px;"></span>
                    <input type="text" value="${result.cornerValues?.bottomLeftRadius || ''}" 
                           ${result.cornerValues?.bottomLeftRadius ? '' : 'disabled'} 
                           style="width: 24px; height: 20px; font-size: 10px; text-align: center; border: 1px solid #d1d5db; border-radius: 2px; outline: none;">
                  </div>
                  <div style="display: flex; align-items: center; gap: 3px;">
                    <input type="text" value="${result.cornerValues?.bottomRightRadius || ''}" 
                           ${result.cornerValues?.bottomRightRadius ? '' : 'disabled'} 
                           style="width: 24px; height: 20px; font-size: 10px; text-align: center; border: 1px solid #d1d5db; border-radius: 2px; outline: none;">
                    <span style="width: 5px; height: 5px; border-right: 2px solid #e5e7eb; border-bottom: 2px solid #e5e7eb; border-radius: 0 0 1px 0;"></span>
                  </div>
                </div>
              </div>
              ` : ''}
              <div class="simple-dropdown" data-node-id="${result.node?.id || ''}" data-result-type="${result.type}" style="position: relative;">
                <button class="btn btn-primary dropdown-trigger" style="background: white !important; color: #6c757d !important;">
                  <span class="dropdown-text">${dropdownText}</span>
                  <svg class="dropdown-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px; color: #6c757d; transition: transform 0.2s ease;">
                    <path d="m6 9 6 6 6-6"/>
                  </svg>
                </button>
                <div class="dropdown-options" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid var(--color-gray-300); border-radius: 0 0 6px 6px; box-shadow: var(--shadow-lg); z-index: 1000; max-height: 200px; overflow-y: auto; display: none;">
                  <!-- Options will be populated by JavaScript -->
                </div>
              </div>
              <button class="btn btn-primary update-btn" data-node-id="${result.node?.id || ''}" data-result-type="${result.type}" disabled>Update</button>
              <button class="btn-danger">Ignore</button>
            </div>
            <button class="btn btn-icon view-node-btn" data-node-id="${result.node?.id || ''}">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
              </svg>
            </button>
          </div>`
    })

    console.log('🔍 Setting collapsed content HTML with', nodeIssues.length, 'issues')
    collapsedContent.innerHTML = html

    // After setting the HTML, we need to set up the event handlers for the dropdowns and buttons
    // This is important because the collapsed view now has the same interactive elements
    setTimeout(() => {
      setupValidationEventHandlers()
    }, 100)
  }

  // Validation Results Screen Tab Functionality
  document.addEventListener('DOMContentLoaded', function () {
    // Tab switching for validation results - moved to main tab handler below

    // Add event handlers for tab navigation icons
    const minimizeBtn = document.getElementById('minimize-btn')
    const hamburgerBtn = document.getElementById('hamburger-menu-btn')

    if (minimizeBtn) {
      // Track minimize state
      let isMinimized = false

      minimizeBtn.addEventListener('click', function () {
        console.log('Minimize/Expand button clicked, current state:', isMinimized)

        if (!isMinimized) {
          // Minimize: resize to collapsed validation results size
          console.log('Minimizing to collapsed size')
          parent.postMessage({
            pluginMessage: {
              type: 'resize-ui',
              sizeMode: 'validation-results-collapsed'
            }
          }, '*')

          // Enable selection tracking for collapsed view
          parent.postMessage({
            pluginMessage: {
              type: 'enable-selection-tracking'
            }
          }, '*')

          // Change icon to expand (diagonal arrows pointing outward)
          minimizeBtn.innerHTML = `
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          `
          minimizeBtn.title = "Expand"

          // Hide the validation results content and show collapsed view
          const resultsContent = document.getElementById('validation-results-content')
          const collapsedContent = document.getElementById('collapsed-view-content')

          // Hide only the tabs section, keep the action buttons visible
          const categoryTabs = document.getElementById('category-tabs')
          const statusTabs = document.getElementById('status-tabs')
          const separator = document.querySelector('#validation-results-screen div[style*="width: 1px"]')
          const issuesCountHeader = document.querySelector('#validation-results-screen > div > div:nth-child(2)')

          if (categoryTabs) {
            categoryTabs.style.display = 'none'
          }

          if (statusTabs) {
            statusTabs.style.display = 'none'
          }

          if (separator) {
            separator.style.display = 'none'
          }

          if (issuesCountHeader) {
            issuesCountHeader.style.display = 'none'
          }

          if (resultsContent) {
            resultsContent.style.display = 'none'
          }

          if (collapsedContent) {
            console.log('🔍 Showing collapsed content')
            collapsedContent.style.display = 'block'
            // Check if there's a currently selected node and show its issues
            updateCollapsedViewForSelectedNode()
          } else {
            console.log('❌ Collapsed content element not found')
          }

          isMinimized = true
          window.isValidationMinimized = true
        } else {
          // Expand: resize back to full validation results screen size
          console.log('Expanding back to full size')
          parent.postMessage({
            pluginMessage: {
              type: 'resize-ui',
              sizeMode: 'validation-results'
            }
          }, '*')

          // Disable selection tracking when expanded
          parent.postMessage({
            pluginMessage: {
              type: 'disable-selection-tracking'
            }
          }, '*')

          // Change icon back to minimize (horizontal line)
          minimizeBtn.innerHTML = `
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path d="M6 12h12" stroke-width="2" stroke-linecap="round"/>
            </svg>
          `
          minimizeBtn.title = "Minimize"

          // Show the validation results content and hide collapsed view
          const resultsContent = document.getElementById('validation-results-content')
          const collapsedContent = document.getElementById('collapsed-view-content')

          // Show the tabs section and issues count again
          const categoryTabs = document.getElementById('category-tabs')
          const statusTabs = document.getElementById('status-tabs')
          const separator = document.querySelector('#validation-results-screen div[style*="width: 1px"]')
          const issuesCountHeader = document.querySelector('#validation-results-screen > div > div:nth-child(2)')

          if (categoryTabs) {
            categoryTabs.style.display = 'flex'
          }

          if (statusTabs) {
            statusTabs.style.display = 'flex'
          }

          if (separator) {
            separator.style.display = 'block'
          }

          if (issuesCountHeader) {
            issuesCountHeader.style.display = 'block'
          }

          const contentWrapper = document.getElementById('tab-content-wrapper')
          if (contentWrapper) {
            contentWrapper.style.justifyContent = 'space-between'
          }

          if (resultsContent) {
            resultsContent.style.display = 'block'
          }

          if (collapsedContent) {
            collapsedContent.style.display = 'none'
          }

          isMinimized = false
          window.isValidationMinimized = false
        }
      })
    }

    if (hamburgerBtn) {
      // Create dropdown menu
      const menuDropdown = document.createElement('div')
      menuDropdown.id = 'hamburger-menu-dropdown'
      menuDropdown.style.cssText = `
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid var(--color-gray-300);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-lg);
        z-index: 1000;
        min-width: 150px;
        display: none;
      `

      // Add menu items
      menuDropdown.innerHTML = `
        <div class="menu-item" data-action="start-over" style="padding: 12px 16px; cursor: pointer; color: var(--color-gray-700); transition: background-color 0.2s ease; border-bottom: 1px solid var(--color-gray-100);">
          <div style="display: flex; align-items: center; gap: 8px;">
            <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M21 3v5h-5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M8 16H3v5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Start Over</span>
          </div>
        </div>
      `

      // Position the dropdown relative to the hamburger button
      hamburgerBtn.style.position = 'relative'
      hamburgerBtn.appendChild(menuDropdown)

      // Toggle dropdown on button click
      hamburgerBtn.addEventListener('click', function (e) {
        e.stopPropagation()
        console.log('Hamburger menu button clicked')

        const isVisible = menuDropdown.style.display === 'block'
        if (isVisible) {
          menuDropdown.style.display = 'none'
        } else {
          menuDropdown.style.display = 'block'
        }
      })

      // Handle menu item clicks
      menuDropdown.addEventListener('click', function (e) {
        e.stopPropagation()
        const menuItem = e.target.closest('.menu-item')
        if (menuItem) {
          const action = menuItem.getAttribute('data-action')
          console.log('Menu item clicked:', action)

          // Hide the dropdown
          menuDropdown.style.display = 'none'

          // Handle the action
          if (action === 'start-over') {
            console.log('Starting over - going to home screen')

            // Clear updated items to reset validation state
            window.updatedItems = new Set()

            // Go back to home screen (one more screen back)
            parent.postMessage({
              pluginMessage: {
                type: 'switch-mode',
                mode: 'home'
              }
            }, '*')
          }
        }
      })

      // Add hover effects to menu items
      const menuItems = menuDropdown.querySelectorAll('.menu-item')
      menuItems.forEach(item => {
        item.addEventListener('mouseenter', function () {
          this.style.background = 'var(--color-gray-50)'
        })
        item.addEventListener('mouseleave', function () {
          this.style.background = 'white'
        })
      })

      // Close dropdown when clicking outside
      document.addEventListener('click', function () {
        menuDropdown.style.display = 'none'
      })
    }

    // Item hover effects
    const items = document.querySelectorAll('#validation-results-screen .item')
    items.forEach(item => {
      item.addEventListener('mouseenter', function () {
        this.style.background = '#fafafa'
      })

      item.addEventListener('mouseleave', function () {
        this.style.background = 'transparent'
      })
    })

    // Button hover effects
    // Update buttons now use CSS hover states via .btn-primary class

    // Ignore buttons now use CSS hover states via .btn-danger class

    // Select dropdown effects
    const selects = document.querySelectorAll('#validation-results-screen select')
    selects.forEach(select => {
      select.addEventListener('mouseenter', function () {
        this.style.borderColor = '#999'
      })

      select.addEventListener('mouseleave', function () {
        if (!this.matches(':focus')) {
          this.style.borderColor = '#ddd'
        }
      })

      select.addEventListener('focus', function () {
        this.style.borderColor = '#1a73e8'
        this.style.outline = 'none'
      })

      select.addEventListener('blur', function () {
        this.style.borderColor = '#ddd'
      })
    })

    // Eye icon hover effects
    const eyeIcons = document.querySelectorAll('#validation-results-screen .eye-icon')
    eyeIcons.forEach(icon => {
      icon.addEventListener('mouseenter', function () {
        this.style.color = '#333'
      })

      icon.addEventListener('mouseleave', function () {
        this.style.color = '#666'
      })
    })


  })



</script>